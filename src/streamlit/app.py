"""
CP2B Maps - Clean Multi-Page Streamlit Application
Simple and robust biogas potential analysis for S√£o Paulo municipalities
"""

import streamlit as st

# Configure page layout for wide mode
st.set_page_config(
    page_title="CP2B Maps",
    page_icon="üó∫Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"  # This ensures the sidebar is visible and open on load
)
import pandas as pd
import folium
from streamlit_folium import st_folium
import sqlite3
import plotly.express as px
import plotly.graph_objects as go
from pathlib import Path
import numpy as np
import logging
from folium.plugins import MiniMap, HeatMap, MarkerCluster
import re  # We need this for parsing the popup
import streamlit.components.v1 as components
import geopandas as gpd
import pickle
import os
from functools import lru_cache

# Importar sistema de rasters - com fallback se n√£o estiver dispon√≠vel
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))

# Configure logging para DEBUG
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    stream=sys.stdout
)
logger = logging.getLogger(__name__)

try:
    from raster import RasterLoader, get_raster_loader, create_mapbiomas_legend, analyze_raster_in_radius
    HAS_RASTER_SYSTEM = True
except ImportError as e:
    HAS_RASTER_SYSTEM = False
    RasterLoader = None
    get_raster_loader = None
    create_mapbiomas_legend = None
    analyze_raster_in_radius = None
    logger.warning(f"Sistema de rasters n√£o dispon√≠vel: {e}")

# ============================================================================
# SISTEMA DE CACHE OTIMIZADO PARA SHAPEFILES
# ============================================================================

@st.cache_data(ttl=3600)  # Cache por 1 hora
def load_shapefile_cached(shapefile_path, simplify_tolerance=0.001):
    """Carrega shapefile com cache e simplifica√ß√£o opcional"""
    try:
        if not os.path.exists(shapefile_path):
            return None
            
        gdf = gpd.read_file(shapefile_path)
        
        # Converter para WGS84 se necess√°rio
        if gdf.crs and gdf.crs != 'EPSG:4326':
            gdf = gdf.to_crs('EPSG:4326')
        
        # CORRE√á√ÉO: Converter colunas problem√°ticas para string para evitar erro de serializa√ß√£o
        for col in gdf.columns:
            if col != 'geometry':
                if gdf[col].dtype == 'datetime64[ns]' or str(gdf[col].dtype).startswith('datetime'):
                    gdf[col] = gdf[col].astype(str)
                elif gdf[col].dtype == 'object':
                    # Converter objetos complexos para string tamb√©m
                    gdf[col] = gdf[col].astype(str)
        
        # Simplificar geometrias complexas para melhor performance
        if simplify_tolerance > 0:
            gdf['geometry'] = gdf['geometry'].simplify(simplify_tolerance, preserve_topology=True)
        
        return gdf
    except Exception as e:
        logger.error(f"Erro ao carregar {shapefile_path}: {e}")
        return None

@st.cache_data(ttl=3600)
def prepare_layer_data():
    """Pr√©-carrega todos os dados das camadas uma vez"""
    base_path = Path(__file__).parent.parent.parent / "shapefile"
    geoparquet_path = Path(__file__).parent.parent.parent / "geoparquet"
    
    layers = {}
    
    # Plantas de Biog√°s (pontos - sem simplifica√ß√£o)
    plantas_path = base_path / "Plantas_Biogas_SP.shp" 
    layers['plantas'] = load_shapefile_cached(str(plantas_path), simplify_tolerance=0)
    
    # Gasodutos (linhas - simplifica√ß√£o leve)
    gasodutos_dist = base_path / "Gasodutos_Distribuicao_SP.shp"
    gasodutos_transp = base_path / "Gasodutos_Transporte_SP.shp"
    layers['gasodutos_dist'] = load_shapefile_cached(str(gasodutos_dist), simplify_tolerance=0.0001)
    layers['gasodutos_transp'] = load_shapefile_cached(str(gasodutos_transp), simplify_tolerance=0.0001)
    
    # Rodovias (linhas - simplifica√ß√£o leve)
    rodovias_path = base_path / "Rodovias_Estaduais_SP.shp"
    layers['rodovias'] = load_shapefile_cached(str(rodovias_path), simplify_tolerance=0.0001)
    
    # Rios (linhas - simplifica√ß√£o m√©dia)
    rios_path = base_path / "Rios_SP.shp" 
    layers['rios'] = load_shapefile_cached(str(rios_path), simplify_tolerance=0.001)
    
    # √Åreas Urbanas (pol√≠gonos otimizados via GeoParquet) - LIMITADO para evitar problemas
    areas_path = geoparquet_path / "Areas_Urbanas_SP.parquet"
    if areas_path.exists():
        try:
            areas_gdf = gpd.read_parquet(areas_path)
            if areas_gdf.crs and areas_gdf.crs != 'EPSG:4326':
                areas_gdf = areas_gdf.to_crs('EPSG:4326')
            
            # LIMITAR drasticamente para evitar travamento - apenas 1000 pol√≠gonos m√°ximo
            if len(areas_gdf) > 1000:
                areas_gdf = areas_gdf.sample(n=1000, random_state=42)
            
            # Simplifica√ß√£o muito agressiva para pol√≠gonos complexos
            areas_gdf['geometry'] = areas_gdf['geometry'].simplify(0.005, preserve_topology=True)
            layers['areas_urbanas'] = areas_gdf
        except Exception as e:
            logger.error(f"Erro ao carregar √°reas urbanas: {e}")
            layers['areas_urbanas'] = None
    else:
        layers['areas_urbanas'] = None
    
    # Regi√µes Administrativas (pol√≠gonos - simplifica√ß√£o leve)
    regioes_path = base_path / "Regiao_Adm_SP.shp"
    layers['regioes_admin'] = load_shapefile_cached(str(regioes_path), simplify_tolerance=0.001)
    
    return layers

# ============================================================================
# FUN√á√ïES OTIMIZADAS DE RENDERIZA√á√ÉO DE CAMADAS
# ============================================================================

def add_plantas_layer_fast(m, plantas_gdf):
    """Adiciona camada de plantas de forma otimizada"""
    if plantas_gdf is None or len(plantas_gdf) == 0:
        return
    
    # Usar MarkerCluster para performance com muitos pontos
    marker_cluster = MarkerCluster(name="üè≠ Plantas de Biog√°s").add_to(m)
    
    color_map = {
        'Biog√°s': '#32CD32',
        'Aterro': '#8B4513', 
        'Tratamento': '#4169E1',
        'Outros': '#9370DB'
    }
    
    for _, row in plantas_gdf.iterrows():
        tipo = row.get('TIPO_PLANT', 'Outros')
        color = color_map.get(tipo, '#666666')
        
        folium.CircleMarker(
            location=[row.geometry.y, row.geometry.x],
            radius=6,
            popup=f"<b>{tipo}</b><br>{row.get('SUBTIPO', 'N/A')}",
            tooltip=f"Planta: {tipo}",
            color=color,
            fillColor=color,
            fillOpacity=0.8,
            weight=1
        ).add_to(marker_cluster)

def add_lines_layer_fast(m, gdf, name, color, weight=2):
    """Adiciona camadas de linhas de forma otimizada"""
    if gdf is None or len(gdf) == 0:
        return
    
    # Usar uma √∫nica opera√ß√£o GeoJson para melhor performance
    folium.GeoJson(
        gdf,
        name=name,
        style_function=lambda feature: {
            'color': color,
            'weight': weight,
            'opacity': 0.8
        },
        tooltip=folium.GeoJsonTooltip(fields=gdf.columns[:3].tolist() if len(gdf.columns) > 0 else []),
        popup=False  # Desabilitar popup para performance
    ).add_to(m)

def add_polygons_layer_fast(m, gdf, name, color, fill_opacity=0.3):
    """Adiciona camadas de pol√≠gonos de forma otimizada"""
    if gdf is None or len(gdf) == 0:
        return
    
    folium.GeoJson(
        gdf,
        name=name,
        style_function=lambda feature: {
            'color': color,
            'weight': 1,
            'opacity': 0.8,
            'fillColor': color,
            'fillOpacity': fill_opacity
        },
        tooltip=False,  # Desabilitar tooltip para performance
        popup=False     # Desabilitar popup para performance
    ).add_to(m)

def add_regioes_layer_fast(m, regioes_gdf):
    """Adiciona regi√µes administrativas com cores diferentes"""
    if regioes_gdf is None or len(regioes_gdf) == 0:
        return
    
    colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', 
             '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43']
    
    for idx, row in regioes_gdf.iterrows():
        color = colors[idx % len(colors)]
        folium.GeoJson(
            row.geometry,
            style_function=lambda feature, color=color: {
                'color': color,
                'weight': 2,
                'opacity': 0.8,
                'fillColor': color,
                'fillOpacity': 0.2
            },
            tooltip=f"Regi√£o: {row.get('Nome', 'N/A')}",
            popup=False
        ).add_to(m)

def create_centroid_map_optimized(df, display_col, filters=None, get_legend_only=False, search_term="", viz_type="C√≠rculos Proporcionais", show_mapbiomas_layer=False, mapbiomas_classes=None, show_rios=False, show_rodovias=False, show_plantas_biogas=False, show_gasodutos_dist=False, show_gasodutos_transp=False, show_areas_urbanas=False, show_regioes_admin=False, show_municipios_biogas=True, catchment_info=None):
    """VERS√ÉO ULTRA-OTIMIZADA - Cria mapa folium de forma muito mais r√°pida"""
    
    # Fun√ß√£o otimizada para cria√ß√£o de mapas com camadas customiz√°veis
    
    try:
        # 1. SETUP B√ÅSICO DO MAPA - MINIMAL
        m = folium.Map(
            location=[-22.5, -48.5], 
            zoom_start=7,
            tiles='CartoDB positron',
            prefer_canvas=True  # Melhora performance de renderiza√ß√£o
        )
        
        # Cria um FeatureGroup para a an√°lise de proximidade. Ele ser√° adicionado no final.
        proximity_group = folium.FeatureGroup(name="√Årea de An√°lise", show=True)
        
        # 1.1. ADICIONAR LIMITE DO ESTADO DE S√ÉO PAULO (SEMPRE VIS√çVEL)
        try:
            sp_border_path = Path(__file__).parent.parent.parent / "shapefile" / "Limite_SP.shp"
            if sp_border_path.exists():
                sp_border = gpd.read_file(sp_border_path)
                if sp_border.crs != 'EPSG:4326':
                    sp_border = sp_border.to_crs('EPSG:4326')
                
                folium.GeoJson(
                    sp_border,
                    style_function=lambda x: {
                        'fillColor': 'rgba(0,0,0,0)', # Sem preenchimento
                        'color': '#2E8B57',          # Verde escuro
                        'weight': 2,                 # Espessura da linha
                        'opacity': 0.7,              # Opacidade da linha
                        'dashArray': '5, 5'          # Linha tracejada
                    },
                    tooltip='Estado de S√£o Paulo',
                    interactive=False  # N√£o clic√°vel
                ).add_to(m)
        except Exception as e:
            # Falha silenciosa - se n√£o conseguir carregar, continua sem o limite
            pass
        
        # Remover todos os debug prints/writes para melhor performance
        if df.empty:
            return m, ""
        
        # 2. PR√â-CARREGAR TODAS AS CAMADAS DE UMA VEZ (CACHE)
        with st.spinner("‚ö° Carregando dados das camadas..."):
            layer_data = prepare_layer_data()
        
        # 3. ADICIONAR CAMADAS SELECIONADAS - OTIMIZADO
        layers_added = []
        
        if show_plantas_biogas and layer_data['plantas'] is not None:
            add_plantas_layer_fast(m, layer_data['plantas'])
            layers_added.append("Plantas de Biog√°s")
        
        if show_gasodutos_dist and layer_data['gasodutos_dist'] is not None:
            add_lines_layer_fast(m, layer_data['gasodutos_dist'], "Gasodutos Distribui√ß√£o", "#0066CC")
            layers_added.append("Gasodutos Distribui√ß√£o")
            
        if show_gasodutos_transp and layer_data['gasodutos_transp'] is not None:
            add_lines_layer_fast(m, layer_data['gasodutos_transp'], "Gasodutos Transporte", "#CC0000", weight=4)
            layers_added.append("Gasodutos Transporte")
        
        if show_rodovias and layer_data['rodovias'] is not None:
            add_lines_layer_fast(m, layer_data['rodovias'], "Rodovias Estaduais", "#FF4500", weight=2)
            layers_added.append("Rodovias")
            
        if show_rios and layer_data['rios'] is not None:
            add_lines_layer_fast(m, layer_data['rios'], "Rios Principais", "#1E90FF", weight=2)
            layers_added.append("Rios")
        
        if show_areas_urbanas and layer_data['areas_urbanas'] is not None:
            # Usar amostragem para √°reas urbanas se houver muitos pol√≠gonos
            areas_sample = layer_data['areas_urbanas']
            if len(areas_sample) > 5000:  # Limitar para performance
                areas_sample = areas_sample.sample(n=5000)
            add_polygons_layer_fast(m, areas_sample, "√Åreas Urbanas", "#DEB887", fill_opacity=0.3)
            layers_added.append("√Åreas Urbanas")
        
        if show_regioes_admin and layer_data['regioes_admin'] is not None:
            add_regioes_layer_fast(m, layer_data['regioes_admin'])
            layers_added.append("Regi√µes Administrativas")
        
        # 4. CARREGAR DADOS DOS MUNIC√çPIOS - SEMPRE ATIVADO
        df_merged = None
        if show_municipios_biogas and not df.empty:
            try:
                centroid_path = Path(__file__).parent.parent.parent / "shapefile" / "municipality_centroids.parquet"
                if centroid_path.exists():
                    centroids_df = pd.read_parquet(centroid_path)
                    
                    # O arquivo tem lat/lon em vez de geometry - vamos criar geometry a partir dessas colunas
                    if 'lat' in centroids_df.columns and 'lon' in centroids_df.columns:
                        # Converter apenas colunas num√©ricas espec√≠ficas para tipos nativos do Python
                        numeric_cols = ['lat', 'lon', 'cd_mun']
                        for col in numeric_cols:
                            if col in centroids_df.columns and centroids_df[col].dtype in ['int32', 'int64', 'float32', 'float64']:
                                centroids_df[col] = centroids_df[col].astype(float)
                        
                        # Criar geometrias Point a partir de lat/lon
                        from shapely.geometry import Point
                        centroids_df['geometry'] = centroids_df.apply(lambda row: Point(float(row['lon']), float(row['lat'])), axis=1)
                        centroids_gdf = gpd.GeoDataFrame(centroids_df, crs='EPSG:4326')
                        
                        df_merged = centroids_gdf.merge(df, on='cd_mun', how='inner')
                        
                        # CORRE√á√ÉO: Ap√≥s o merge, as colunas de nome ficam como nome_municipio_x e nome_municipio_y
                        # Vamos criar uma coluna √∫nica 'nome_municipio' usando os dados do main data (y)
                        if 'nome_municipio_y' in df_merged.columns:
                            df_merged['nome_municipio'] = df_merged['nome_municipio_y']
                        elif 'nome_municipio_x' in df_merged.columns:
                            df_merged['nome_municipio'] = df_merged['nome_municipio_x']
                        
                        # Converter apenas colunas num√©ricas espec√≠ficas (n√£o textuais) para tipos nativos do Python
                        numeric_cols_to_convert = ['lat', 'lon', 'cd_mun', 'populacao_2022', 'total_final_nm_ano', 'total_agricola_nm_ano', 'total_pecuaria_nm_ano', 'total_urbano_nm_ano']
                        for col in df_merged.columns:
                            if col != 'geometry' and col != 'nome_municipio' and col != 'nome_municipio_x' and col != 'nome_municipio_y' and df_merged[col].dtype in ['int32', 'int64', 'float32', 'float64']:
                                try:
                                    df_merged[col] = df_merged[col].astype(float)
                                except:
                                    pass  # Pular se n√£o conseguir converter
                        
                        if not df_merged.empty and display_col in df_merged.columns:
                            # Adicionar c√≠rculos dos munic√≠pios de forma otimizada
                            add_municipality_circles_fast(m, df_merged, display_col, viz_type)
                            layers_added.append("Potencial de Biog√°s dos Munic√≠pios")
                        else:
                            # Debugging para entender o problema
                            st.warning(f"‚ö†Ô∏è Debug: df_merged empty={df_merged.empty if df_merged is not None else 'None'}, display_col='{display_col}' in columns={display_col in df_merged.columns if df_merged is not None else 'No df_merged'}")
                    else:
                        st.warning("‚ö†Ô∏è Colunas 'lat' e 'lon' n√£o encontradas nos centroids")
                else:
                    st.warning("‚ö†Ô∏è Arquivo municipality_centroids.parquet n√£o encontrado")
            except Exception as e:
                # Debug em vez de falha silenciosa
                st.error(f"‚ùå Erro ao carregar c√≠rculos dos munic√≠pios: {e}")
                import traceback
                st.code(traceback.format_exc())
        
        # 5. REMOVER CONTROLES DO FOLIUM - USAMOS SIDEBAR AGORA
        # LayerControl removido para deixar espa√ßo para a legenda bonita
        
        # 6. CRIAR LEGENDA BONITA (RESTAURADA DO ORIGINAL)
        legend_html = ""
        if show_municipios_biogas and df_merged is not None and not df_merged.empty:
            legend_html = f'''
            <div style="font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 13px;">
                <h4 style="margin-top: 0; margin-bottom: 12px; color: #2E8B57; text-align: center;">
                    üó∫Ô∏è Legenda do Mapa
                </h4>
                <div style="margin-bottom: 10px;">
                    <strong>üìä Dados:</strong> {display_col.replace('_', ' ').title()}
                </div>
                <div style="margin-bottom: 12px;">
                    <strong>üìà Faixa de Potencial:</strong><br>
                    Min: {df_merged[display_col].min():,.0f} Nm¬≥/ano<br>
                    Max: {df_merged[display_col].max():,.0f} Nm¬≥/ano
                </div>
                <div style="margin-bottom: 12px;">
                    <strong>üé® Escala de Cores:</strong><br>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #ffffcc; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>Muito Baixo</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #c7e9b4; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>Baixo</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #7fcdbb; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>M√©dio</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #41b6c4; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>Alto</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #253494; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>Muito Alto</span>
                    </div>
                </div>
                <div style="margin-bottom: 12px;">
                    <strong>üìè Tamanho do C√≠rculo:</strong><br>
                    <small>Proporcional ao potencial de biog√°s</small>
                </div>
                {f"<div><strong>üó∫Ô∏è Camadas Ativas:</strong><br><small>{', '.join(layers_added)}</small></div>" if layers_added else ""}
            </div>
            '''
        elif layers_added:
            legend_html = f"<div style='background: white; padding: 10px; border: 2px solid #333; border-radius: 5px;'><p><strong>Camadas ativas:</strong> {', '.join(layers_added)}</p></div>"
        
        # 7. ADICIONAR LEGENDA FLUTUANTE NO MAPA (CANTO SUPERIOR DIREITO)
        if show_municipios_biogas and df_merged is not None and not df_merged.empty:
            floating_legend_html = f'''
        <div style="position: fixed; 
                    top: 10px; right: 10px; width: 250px; height: auto; 
                    background-color: rgba(255, 255, 255, 0.95); 
                    border: 2px solid #2E8B57;
                    z-index:9999; font-size:12px; border-radius: 8px; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    font-family: 'Segoe UI', Tahoma, sans-serif;">
            <h4 style="margin-top: 0; margin-bottom: 8px; color: #2E8B57; text-align: center; font-size: 14px;">
                üó∫Ô∏è Legenda
            </h4>
            <div style="margin-bottom: 8px; font-size: 11px;">
                <strong>üìä Dados:</strong> {display_col.replace('_', ' ').title()}
            </div>
            <div style="margin-bottom: 8px; font-size: 11px;">
                <strong>üìà Faixa:</strong><br>
                Min: {df_merged[display_col].min():,.0f}<br>
                Max: {df_merged[display_col].max():,.0f}
            </div>
            <div style="margin-bottom: 8px;">
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #ffffcc; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">Muito Baixo</span>
                </div>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #c7e9b4; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">Baixo</span>
                </div>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #7fcdbb; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">M√©dio</span>
                </div>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #41b6c4; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">Alto</span>
                </div>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #253494; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">Muito Alto</span>
                </div>
            </div>
            <div style="font-size: 10px;">
                <strong>üìè Tamanho:</strong> Proporcional ao potencial
            </div>
        </div>
        '''
            # Adicionar a legenda flutuante ao mapa
            m.get_root().html.add_child(folium.Element(floating_legend_html))
        
        # --- CAMADA MAPBIOMAS COM RASTER OTIMIZADO ---
        if show_mapbiomas_layer:
            if not HAS_RASTER_SYSTEM:
                st.warning("‚ö†Ô∏è Sistema de rasters n√£o dispon√≠vel. Instale as depend√™ncias necess√°rias.")
                return m, legend_html
                
            try:
                # Verificar se o caminho do raster existe
                project_root = Path(__file__).parent.parent.parent
                raster_dir = project_root / "rasters"
                
                if not raster_dir.exists():
                    st.error(f"‚ùå Diret√≥rio 'rasters' n√£o encontrado: {raster_dir}")
                else:
                    raster_loader = RasterLoader(str(raster_dir))
                    
                    # Lista rasters dispon√≠veis
                    available_rasters = raster_loader.list_available_rasters()
                    mapbiomas_rasters = [r for r in available_rasters if 'mapbiomas' in r.lower() or 'agropecuaria' in r.lower()]
                    
                    if mapbiomas_rasters:
                        # Usa o primeiro raster encontrado
                        raster_path = mapbiomas_rasters[0]
                        data, metadata = raster_loader.load_raster(raster_path)
                        
                        if data is not None and metadata is not None:
                            # Cria sobreposi√ß√£o para o Folium com classes filtradas
                            overlay = raster_loader.raster_to_folium_overlay(data, metadata, opacity=0.7, selected_classes=mapbiomas_classes)
                            
                            if overlay is not None:
                                # Cria FeatureGroup para controle de camadas
                                mapbiomas_group = folium.FeatureGroup(name="MapBiomas - Agropecu√°ria SP", show=True)
                                overlay.add_to(mapbiomas_group)
                                mapbiomas_group.add_to(m)
                                
                                # Adiciona legenda com classes filtradas
                                legend_mapbiomas = create_mapbiomas_legend(selected_classes=mapbiomas_classes)
                                m.get_root().html.add_child(folium.Element(legend_mapbiomas))
                            else:
                                st.warning("‚ö†Ô∏è Erro ao processar raster para visualiza√ß√£o")
                        else:
                            st.warning("‚ö†Ô∏è Erro ao carregar dados do raster")
                    else:
                        st.info("üìÅ Nenhum arquivo raster MapBiomas encontrado na pasta 'rasters/'")
                        st.info("üí° Baixe o GeoTIFF do Google Earth Engine e coloque na pasta 'rasters/'")
                        
            except ImportError as e:
                st.error("‚ùå Sistema de rasters n√£o dispon√≠vel. Verifique se 'rasterio' est√° instalado.")
            except Exception as e:
                st.error(f"‚ö†Ô∏è Erro ao carregar camada MapBiomas: {str(e)}")
        
        return m, legend_html
        
    except Exception as e:
        st.error(f"‚ùå Erro ao criar mapa: {e}")
        # Retornar mapa b√°sico em caso de erro
        basic_map = folium.Map(location=[-22.5, -48.5], zoom_start=7)
        return basic_map, ""

def add_municipality_circles_fast(m, df_merged, display_col, viz_type):
    """Adiciona visualiza√ß√µes dos munic√≠pios com diferentes estilos baseados em viz_type"""
    print(f"===> DEBUG VIZ_TYPE: Fun√ß√£o add_municipality_circles_fast recebendo viz_type = '{viz_type}'")
    
    if df_merged.empty or display_col not in df_merged.columns:
        return
    
    # Usar apenas uma amostra se houver muitos munic√≠pios para melhor performance
    if len(df_merged) > 500:
        df_sample = df_merged.nlargest(500, display_col)  # Top 500 maiores valores
    else:
        df_sample = df_merged
    
    # Preparar dados comuns
    values = df_sample[display_col].fillna(0)
    max_val = float(values.max()) if values.max() > 0 else 1.0
    
    # Cores da legenda para os diferentes n√≠veis
    color_scale = ['#ffffcc', '#c7e9b4', '#7fcdbb', '#41b6c4', '#253494']
    
    def get_color_for_value(value, max_val):
        if max_val == 0:
            return color_scale[0]
        normalized = value / max_val
        if normalized <= 0.2:
            return color_scale[0]  # Muito Baixo
        elif normalized <= 0.4:
            return color_scale[1]  # Baixo
        elif normalized <= 0.6:
            return color_scale[2]  # M√©dio
        elif normalized <= 0.8:
            return color_scale[3]  # Alto
        else:
            return color_scale[4]  # Muito Alto
    
    # ==== L√ìGICA DE SELE√á√ÉO DE VISUALIZA√á√ÉO RESTAURADA ====
    print(f"===> DEBUG VIZ_TYPE: Checando a condi√ß√£o para '{viz_type}'")
    
    if viz_type == "C√≠rculos Proporcionais":
        print("===> DEBUG VIZ_TYPE: Entrando no bloco de C√≠rculos Proporcionais.")
        # Implementa√ß√£o atual - c√≠rculos proporcionais
        if values.max() > 0:
            sizes = ((values / values.max()) * 15 + 3).astype(float)
        else:
            sizes = pd.Series([5.0] * len(df_sample))
        
        for idx, row in df_sample.iterrows():
            try:
                if hasattr(row, 'geometry') and row.geometry:
                    lat, lon = float(row.geometry.y), float(row.geometry.x)
                    size = float(sizes.loc[idx])
                    value = float(values.loc[idx])
                    color = get_color_for_value(value, max_val)
                    
                    municipio_nome = 'N/A'
                    if 'nome_municipio' in row.index:
                        municipio_nome = str(row['nome_municipio'])
                    elif hasattr(row, 'nome_municipio'):
                        municipio_nome = str(row.nome_municipio)
                    
                    popup = f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano"
                    
                    folium.CircleMarker(
                        location=[lat, lon],
                        radius=size,
                        popup=popup,
                        tooltip=municipio_nome,
                        color='#333333',
                        fillColor=color,
                        fillOpacity=0.8,
                        weight=1
                    ).add_to(m)
            except Exception:
                continue
                
    elif viz_type == "Mapa de Calor (Heatmap)":
        print("===> DEBUG VIZ_TYPE: Entrando no bloco de Mapa de Calor.")
        try:
            from folium.plugins import HeatMap
            heat_data = []
            for idx, row in df_sample.iterrows():
                try:
                    if hasattr(row, 'geometry') and row.geometry:
                        lat, lon = float(row.geometry.y), float(row.geometry.x)
                        value = float(values.loc[idx])
                        if value > 0:  # S√≥ incluir valores positivos no heatmap
                            # Normalizar valor para o heatmap (0-1)
                            normalized_value = value / max_val
                            heat_data.append([lat, lon, normalized_value])
                except Exception:
                    continue
            
            if heat_data:
                HeatMap(heat_data, radius=15, blur=10, max_zoom=1).add_to(m)
            else:
                # Fallback para c√≠rculos se heatmap falhar
                print("===> DEBUG VIZ_TYPE: Fallback para c√≠rculos - dados insuficientes para heatmap.")
                # Implementar c√≠rculos simples como fallback
                for idx, row in df_sample.iterrows():
                    try:
                        if hasattr(row, 'geometry') and row.geometry:
                            lat, lon = float(row.geometry.y), float(row.geometry.x)
                            value = float(values.loc[idx])
                            color = get_color_for_value(value, max_val)
                            
                            municipio_nome = 'N/A'
                            if 'nome_municipio' in row.index:
                                municipio_nome = str(row['nome_municipio'])
                                
                            folium.CircleMarker(
                                location=[lat, lon],
                                radius=5,
                                popup=f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano",
                                tooltip=municipio_nome,
                                color='#333333',
                                fillColor=color,
                                fillOpacity=0.7,
                                weight=1
                            ).add_to(m)
                    except Exception:
                        continue
        except ImportError:
            print("===> DEBUG VIZ_TYPE: HeatMap n√£o dispon√≠vel - usando fallback para c√≠rculos.")
            # Fallback para c√≠rculos se HeatMap n√£o estiver dispon√≠vel
            for idx, row in df_sample.iterrows():
                try:
                    if hasattr(row, 'geometry') and row.geometry:
                        lat, lon = float(row.geometry.y), float(row.geometry.x)
                        value = float(values.loc[idx])
                        color = get_color_for_value(value, max_val)
                        
                        municipio_nome = 'N/A'
                        if 'nome_municipio' in row.index:
                            municipio_nome = str(row['nome_municipio'])
                            
                        folium.CircleMarker(
                            location=[lat, lon],
                            radius=8,
                            popup=f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano",
                            tooltip=municipio_nome,
                            color='red',
                            fillColor='orange',
                            fillOpacity=0.7,
                            weight=2
                        ).add_to(m)
                except Exception:
                    continue
                    
    elif viz_type == "Agrupamentos (Clusters)":
        print("===> DEBUG VIZ_TYPE: Entrando no bloco de Agrupamentos.")
        try:
            from folium.plugins import MarkerCluster
            marker_cluster = MarkerCluster().add_to(m)
            
            for idx, row in df_sample.iterrows():
                try:
                    if hasattr(row, 'geometry') and row.geometry:
                        lat, lon = float(row.geometry.y), float(row.geometry.x)
                        value = float(values.loc[idx])
                        color = get_color_for_value(value, max_val)
                        
                        municipio_nome = 'N/A'
                        if 'nome_municipio' in row.index:
                            municipio_nome = str(row['nome_municipio'])
                        elif hasattr(row, 'nome_municipio'):
                            municipio_nome = str(row.nome_municipio)
                        
                        # Usar tamanho baseado no valor para diferencia√ß√£o
                        if values.max() > 0:
                            size = max(5, int((value / max_val) * 20))
                        else:
                            size = 8
                        
                        marker = folium.CircleMarker(
                            location=[lat, lon],
                            radius=size,
                            popup=f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano",
                            tooltip=municipio_nome,
                            color='#333333',
                            fillColor=color,
                            fillOpacity=0.8,
                            weight=1
                        )
                        marker_cluster.add_child(marker)
                except Exception:
                    continue
        except ImportError:
            print("===> DEBUG VIZ_TYPE: MarkerCluster n√£o dispon√≠vel - usando fallback para c√≠rculos.")
            # Fallback para c√≠rculos se MarkerCluster n√£o estiver dispon√≠vel
            for idx, row in df_sample.iterrows():
                try:
                    if hasattr(row, 'geometry') and row.geometry:
                        lat, lon = float(row.geometry.y), float(row.geometry.x)
                        value = float(values.loc[idx])
                        color = get_color_for_value(value, max_val)
                        
                        municipio_nome = 'N/A'
                        if 'nome_municipio' in row.index:
                            municipio_nome = str(row['nome_municipio'])
                            
                        folium.CircleMarker(
                            location=[lat, lon],
                            radius=8,
                            popup=f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano",
                            tooltip=municipio_nome,
                            color='purple',
                            fillColor='violet',
                            fillOpacity=0.7,
                            weight=2
                        ).add_to(m)
                except Exception:
                    continue
                    
    elif viz_type == "Mapa de Preenchimento (Coropl√©tico)":
        print("===> DEBUG VIZ_TYPE: Entrando no bloco Coropl√©tico REAL.")
        try:
            # 1. Carregar as geometrias dos pol√≠gonos (usando a fun√ß√£o que j√° existe)
            print("===> DEBUG: Carregando pol√≠gonos dos munic√≠pios...")
            gdf_polygons = load_optimized_geometries("medium_detail")

            if gdf_polygons is None or 'cd_mun' not in gdf_polygons.columns:
                print("===> DEBUG: Falha ao carregar geometrias - usando fallback para c√≠rculos.")
                # Fallback para c√≠rculos se n√£o conseguir carregar
                for idx, row in df_sample.iterrows():
                    try:
                        if hasattr(row, 'geometry') and row.geometry:
                            lat, lon = float(row.geometry.y), float(row.geometry.x)
                            value = float(values.loc[idx])
                            color = get_color_for_value(value, max_val)
                            
                            municipio_nome = 'N/A'
                            if 'nome_municipio' in row.index:
                                municipio_nome = str(row['nome_municipio'])
                            elif hasattr(row, 'nome_municipio'):
                                municipio_nome = str(row.nome_municipio)
                            
                            folium.CircleMarker(
                                location=[lat, lon],
                                radius=12,
                                popup=f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano",
                                tooltip=municipio_nome,
                                color=color,
                                fillColor=color,
                                fillOpacity=0.9,
                                weight=2
                            ).add_to(m)
                    except Exception:
                        continue
                return

            print(f"===> DEBUG: Pol√≠gonos carregados: {len(gdf_polygons)} geometrias.")

            # 2. Mesclar dados de potencial com as geometrias
            # Assegurar que 'cd_mun' seja do mesmo tipo em ambos os dataframes
            gdf_polygons['cd_mun'] = gdf_polygons['cd_mun'].astype(str)
            df_merged_copy = df_merged.copy()
            df_merged_copy['cd_mun'] = df_merged_copy['cd_mun'].astype(str)
            
            df_choropleth = gdf_polygons.merge(df_merged_copy, on='cd_mun', how='inner')

            if df_choropleth.empty:
                print("===> DEBUG: N√£o foi poss√≠vel combinar dados - usando fallback para c√≠rculos.")
                # Fallback para c√≠rculos se merge falhar
                for idx, row in df_sample.iterrows():
                    try:
                        if hasattr(row, 'geometry') and row.geometry:
                            lat, lon = float(row.geometry.y), float(row.geometry.x)
                            value = float(values.loc[idx])
                            color = get_color_for_value(value, max_val)
                            
                            municipio_nome = 'N/A'
                            if 'nome_municipio' in row.index:
                                municipio_nome = str(row['nome_municipio'])
                                
                            folium.CircleMarker(
                                location=[lat, lon],
                                radius=12,
                                popup=f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano",
                                tooltip=municipio_nome,
                                color=color,
                                fillColor=color,
                                fillOpacity=0.9,
                                weight=2
                            ).add_to(m)
                    except Exception:
                        continue
                return

            print(f"===> DEBUG: Merge conclu√≠do: {len(df_choropleth)} munic√≠pios com dados.")

            # 3. Criar a camada Choropleth
            folium.Choropleth(
                geo_data=df_choropleth,
                name='Potencial de Biog√°s',
                data=df_choropleth,
                columns=['cd_mun', display_col],
                key_on='feature.properties.cd_mun',
                fill_color='YlGnBu',  # Uma escala de cores boa para dados quantitativos
                fill_opacity=0.7,
                line_opacity=0.2,
                line_color='black',
                legend_name=f'Potencial ({display_col.replace("_", " ").title()})',
                highlight=True
            ).add_to(m)

            # 4. (Opcional, mas recomendado) Adicionar tooltips interativos
            style_function = lambda x: {'fillColor': '#ffffff', 'color':'#000000', 'fillOpacity': 0.1, 'weight': 0.1}
            highlight_function = lambda x: {'fillColor': '#000000', 'color':'#000000', 'fillOpacity': 0.50, 'weight': 0.1}
            
            interactive_layer = folium.features.GeoJson(
                df_choropleth,
                style_function=style_function, 
                control=False,
                highlight_function=highlight_function, 
                tooltip=folium.features.GeoJsonTooltip(
                    fields=['nome_municipio', display_col],
                    aliases=['Munic√≠pio: ', 'Potencial: '],
                    style=("background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;") 
                )
            )
            m.add_child(interactive_layer)
            m.keep_in_front(interactive_layer)
            
            print("===> DEBUG: Mapa coropl√©tico criado com sucesso!")

        except Exception as e:
            print(f"===> DEBUG: Erro ao gerar o mapa coropl√©tico: {e}")
            # Fallback para c√≠rculos se algo der errado
            print("===> DEBUG VIZ_TYPE: Fallback para c√≠rculos devido a erro no coropl√©tico.")
            for idx, row in df_sample.iterrows():
                try:
                    if hasattr(row, 'geometry') and row.geometry:
                        lat, lon = float(row.geometry.y), float(row.geometry.x)
                        value = float(values.loc[idx])
                        color = get_color_for_value(value, max_val)
                        
                        municipio_nome = 'N/A'
                        if 'nome_municipio' in row.index:
                            municipio_nome = str(row['nome_municipio'])
                        elif hasattr(row, 'nome_municipio'):
                            municipio_nome = str(row.nome_municipio)
                        
                        folium.CircleMarker(
                            location=[lat, lon],
                            radius=12,
                            popup=f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano",
                            tooltip=municipio_nome,
                            color=color,
                            fillColor=color,
                            fillOpacity=0.9,
                            weight=2
                        ).add_to(m)
                except Exception:
                    continue
    else:
        print(f"===> DEBUG VIZ_TYPE: Tipo n√£o reconhecido '{viz_type}' - usando c√≠rculos proporcionais como fallback.")
        # Fallback para c√≠rculos proporcionais
        if values.max() > 0:
            sizes = ((values / values.max()) * 15 + 3).astype(float)
        else:
            sizes = pd.Series([5.0] * len(df_sample))
        
        for idx, row in df_sample.iterrows():
            try:
                if hasattr(row, 'geometry') and row.geometry:
                    lat, lon = float(row.geometry.y), float(row.geometry.x)
                    size = float(sizes.loc[idx])
                    value = float(values.loc[idx])
                    color = get_color_for_value(value, max_val)
                    
                    municipio_nome = 'N/A'
                    if 'nome_municipio' in row.index:
                        municipio_nome = str(row['nome_municipio'])
                    elif hasattr(row, 'nome_municipio'):
                        municipio_nome = str(row.nome_municipio)
                    
                    popup = f"<b>{municipio_nome}</b><br>{value:,.0f} Nm¬≥/ano"
                    
                    folium.CircleMarker(
                        location=[lat, lon],
                        radius=size,
                        popup=popup,
                        tooltip=municipio_nome,
                        color='#333333',
                        fillColor=color,
                        fillOpacity=0.8,
                        weight=1
                    ).add_to(m)
            except Exception:
                continue


# Constants
RESIDUE_OPTIONS = {
    'Potencial Total': 'total_final_nm_ano',
    'Total Agr√≠cola': 'total_agricola_nm_ano',
    'Total Pecu√°ria': 'total_pecuaria_nm_ano',
    'Total Urbano': 'total_urbano_nm_ano',
    'Cana-de-a√ß√∫car': 'biogas_cana_nm_ano',
    'Soja': 'biogas_soja_nm_ano',
    'Milho': 'biogas_milho_nm_ano',
    'Caf√©': 'biogas_cafe_nm_ano',
    'Citros': 'biogas_citros_nm_ano',
    'Bovinos': 'biogas_bovinos_nm_ano',
    'Su√≠nos': 'biogas_suino_nm_ano',
    'Aves': 'biogas_aves_nm_ano',
    'Piscicultura': 'biogas_piscicultura_nm_ano',
    'Res√≠duos Urbanos': 'rsu_total_nm_ano',
    'Res√≠duos Poda': 'rpo_total_nm_ano'
}

def get_residue_label(column_name):
    """Convert column name back to readable label"""
    # Create reverse mapping
    reverse_options = {v: k for k, v in RESIDUE_OPTIONS.items()}
    return reverse_options.get(column_name, column_name)

# --- CONSTANTE PARA A CAMADA RASTER (USANDO A CAMADA MAIS EST√ÅVEL DO GEOSERVER) ---
RASTER_LAYERS = {
    "Cobertura do Solo (MapBiomas)": {
        "url": "https://brasil.mapbiomas.org/geoserver/wms",
        # Usando a camada de integra√ß√£o da Cole√ß√£o 8. √â a mais confi√°vel para testes.
        "layer": "mapbiomas:mapbiomas_brazil_collection_80_integration_v1", 
        "attr": "MapBiomas Project - Collection 8.0"
    }
}

# Database functions
@st.cache_data
def get_database_path():
    """Get database path"""
    return Path(__file__).parent.parent.parent / "data" / "cp2b_maps.db"

@st.cache_data
def load_municipalities():
    """Load municipality data from database with error handling"""
    try:
        db_path = get_database_path()
        
        if not db_path.exists():
            logger.warning("Database not found")
            return pd.DataFrame()
        
        with sqlite3.connect(db_path) as conn:
            query = "SELECT * FROM municipalities ORDER BY total_final_nm_ano DESC"
            df = pd.read_sql_query(query, conn)
            
            # Convert per capita values to total values by multiplying by population
            if 'rsu_potencial_nm_habitante_ano' in df.columns and 'populacao_2022' in df.columns:
                df['rsu_potencial_nm_ano'] = df['rsu_potencial_nm_habitante_ano'] * df['populacao_2022']
                df['rsu_potencial_nm_ano'] = df['rsu_potencial_nm_ano'].fillna(0)
            
            if 'rpo_potencial_nm_habitante_ano' in df.columns and 'populacao_2022' in df.columns:
                df['rpo_potencial_nm_ano'] = df['rpo_potencial_nm_habitante_ano'] * df['populacao_2022']
                df['rpo_potencial_nm_ano'] = df['rpo_potencial_nm_ano'].fillna(0)
            
            logger.info(f"Loaded {len(df)} municipalities")
            return df
            
    except Exception as e:
        logger.error(f"Error loading data: {e}")
        return pd.DataFrame()

def safe_divide(numerator, denominator, default=0):
    """Safe division with default value"""
    try:
        return numerator / denominator if denominator != 0 else default
    except (TypeError, ZeroDivisionError):
        return default

def format_number(value, unit="Nm¬≥/ano", scale=1):
    """Format numbers with proper scaling"""
    try:
        if pd.isna(value) or value == 0:
            return f"0 {unit}"
        
        scaled_value = value / scale
        if scale >= 1_000_000:
            return f"{scaled_value:.1f}M {unit}"
        elif scale >= 1_000:
            return f"{scaled_value:.0f}K {unit}"
        else:
            return f"{value:,.0f} {unit}"
    except:
        return f"0 {unit}"

# Navigation functions
def render_header():
    """Render application header"""
    st.markdown("""
    <div style='background: linear-gradient(135deg, #2E8B57 0%, #228B22 50%, #32CD32 100%); 
                color: white; padding: 1.5rem; margin: -1rem -1rem 1rem -1rem;
                text-align: center; border-radius: 0 0 15px 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);'>
        <h1 style='margin: 0; font-size: 2.2rem; font-weight: 700;'>üó∫Ô∏è An√°lise de Potencial de Biog√°s</h1>
        <p style='margin: 5px 0 0 0; font-size: 1rem; opacity: 0.9;'>
            645 munic√≠pios de S√£o Paulo
        </p>
    </div>
    """, unsafe_allow_html=True)

def render_navigation():
    """Simple tab-based navigation"""
    tabs = st.tabs([
        "üè† Mapa Principal",
        "üîç Explorar Dados",
        "üìä An√°lises",
        "‚ÑπÔ∏è Sobre"
    ])
    
    return tabs

# Filter functions
def render_sidebar_filters():
    """Render sidebar filters (deprecated - kept for compatibility)"""
    # Simple navigation-only sidebar
    st.sidebar.markdown("""
    <div style='background: #2E8B57; color: white; padding: 0.5rem; margin: -1rem -1rem 1rem -1rem;
                text-align: center; border-radius: 8px;'>
        <h4 style='margin: 0;'>üìä CP2B Maps</h4>
        <p style='margin: 0; font-size: 0.8em;'>Use as abas para navegar</p>
    </div>
    """, unsafe_allow_html=True)
    
    return {
        'residues': [RESIDUE_OPTIONS["Potencial Total"]],
        'display_name': "Potencial Total",
        'search': "",
        'show_zeros': False,
        'max_count': 50
    }

def render_compact_filters(page_key="default"):
    """Render compact filters on main page"""
    # Create compact filter container
    with st.container():
        st.markdown("""
        <div style='background: rgba(255,255,255,0.95); padding: 1rem; border-radius: 10px; 
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 1rem;'>
        </div>
        """, unsafe_allow_html=True)
        
        # Use columns for horizontal layout
        col1, col2, col3, col4 = st.columns([2, 2, 1.5, 1.5])
        
        with col1:
            # Selection mode
            mode = st.radio(
                "Modo:",
                ["Individual", "M√∫ltiplos"],
                horizontal=True,
                key=f"{page_key}_selection_mode"
            )
        
        with col2:
            if mode == "Individual":
                selected = st.selectbox("Tipo de Res√≠duo:", list(RESIDUE_OPTIONS.keys()), key=f"{page_key}_residue_select")
                residues = [RESIDUE_OPTIONS[selected]]
                display_name = selected
            else:
                selected_list = st.multiselect(
                    "Tipos:",
                    list(RESIDUE_OPTIONS.keys()),
                    default=["Potencial Total"],
                    key=f"{page_key}_residue_multi"
                )
                residues = [RESIDUE_OPTIONS[item] for item in selected_list]
                display_name = f"Soma de {len(residues)} tipos" if len(residues) > 1 else (selected_list[0] if selected_list else "Nenhum")
        
        with col3:
            search = st.text_input("üîç Buscar:", placeholder="Nome do munic√≠pio", key=f"{page_key}_search")
        
        with col4:
            show_zeros = st.checkbox("Valores zero", key=f"{page_key}_zeros")
            max_count = st.slider("Max:", 10, 645, 100, key=f"{page_key}_max")
    
    return {
        'residues': residues,
        'display_name': display_name,
        'search': search,
        'show_zeros': show_zeros,
        'max_count': max_count
    }

def calculate_distance(lat1, lon1, lat2, lon2):
    """Calculate distance between two points using Haversine formula"""
    import math
    
    # Convert latitude and longitude from degrees to radians
    lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])
    
    # Haversine formula
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
    c = 2 * math.asin(math.sqrt(a))
    
    # Radius of Earth in kilometers
    r = 6371
    
    return c * r

def analyze_municipalities_in_radius(df_municipalities, center_lat, center_lon, radius_km):
    """
    Encontra munic√≠pios dentro de um raio e calcula o potencial total.
    """
    if df_municipalities.empty or 'lat' not in df_municipalities.columns:
        return {'total_potential': 0, 'municipality_count': 0, 'municipalities': []}

    municipalities_in_radius = []
    total_potential = 0

    for _, row in df_municipalities.iterrows():
        # Pula munic√≠pios sem coordenadas v√°lidas
        if pd.isna(row['lat']) or pd.isna(row['lon']) or row['lat'] == 0:
            continue

        distance = calculate_distance(center_lat, center_lon, row['lat'], row['lon'])

        if distance <= radius_km:
            potential = row.get('total_final_nm_ano', 0)
            municipalities_in_radius.append({
                'nome': row['nome_municipio'],
                'potencial': potential,
                'distancia_km': round(distance, 1)
            })
            total_potential += potential
    
    # Ordena por dist√¢ncia (do mais pr√≥ximo ao mais distante)
    municipalities_in_radius.sort(key=lambda x: x['distancia_km'])
    
    return {
        'total_potential': total_potential,
        'municipality_count': len(municipalities_in_radius),
        'municipalities': municipalities_in_radius
    }

def calculate_catchment_area(df, center_lat, center_lon, radius_km, display_col):
    """Calculate total potential within a radius from a center point"""
    import pandas as pd
    
    if df.empty:
        return None
    
    # Load centroid data to get coordinates
    try:
        from pathlib import Path
        centroid_path = Path(__file__).parent.parent.parent / "shapefile" / "municipality_centroids.parquet"
        centroids_df = pd.read_parquet(centroid_path)
        
        # Merge with display data
        df_with_coords = centroids_df.merge(df, on='cd_mun', how='inner')
        
        municipalities_in_radius = []
        total_potential = 0
        
        for idx, row in df_with_coords.iterrows():
            try:
                # Get municipality coordinates
                if hasattr(row['geometry'], 'y') and hasattr(row['geometry'], 'x'):
                    mun_lat, mun_lon = float(row['geometry'].y), float(row['geometry'].x)
                elif 'lat' in row and 'lon' in row:
                    mun_lat, mun_lon = float(row['lat']), float(row['lon'])
                else:
                    continue
                
                # Calculate distance
                distance = calculate_distance(center_lat, center_lon, mun_lat, mun_lon)
                
                # Check if within radius
                if distance <= radius_km:
                    potential = float(row[display_col]) if pd.notna(row[display_col]) else 0
                    
                    municipalities_in_radius.append({
                        'name': row.get('nome_municipio', 'N/A'),
                        'distance': distance,
                        'potential': potential,
                        'cd_mun': row['cd_mun']
                    })
                    
                    total_potential += potential
                    
            except (AttributeError, TypeError, ValueError):
                continue
        
        # Sort by potential (descending)
        municipalities_in_radius.sort(key=lambda x: x['potential'], reverse=True)
        
        return {
            'total_potential': total_potential,
            'municipality_count': len(municipalities_in_radius),
            'municipalities': municipalities_in_radius,
            'center_lat': center_lat,
            'center_lon': center_lon,
            'radius_km': radius_km
        }
        
    except Exception as e:
        st.error(f"Erro no c√°lculo de √°rea de capta√ß√£o: {e}")
        return None

def apply_classification(values, method, num_classes):
    """Apply statistical classification to data values"""
    import numpy as np
    
    if len(values) == 0:
        return []
    
    values = np.array(values)
    values = values[~np.isnan(values)]  # Remove NaN values
    
    if len(values) == 0:
        return []
    
    if method == "Linear (Intervalo Uniforme)":
        # Equal interval - divide range into equal parts
        min_val, max_val = values.min(), values.max()
        if max_val == min_val:
            return [min_val] * num_classes
        breaks = np.linspace(min_val, max_val, num_classes + 1)
        
    elif method == "Quantiles (Contagem Igual)":
        # Quantiles - equal count in each class
        percentiles = np.linspace(0, 100, num_classes + 1)
        breaks = np.percentile(values, percentiles)
        
    elif method == "Quebras Naturais (Jenks)":
        # Natural breaks - minimize within-class variance (simplified version)
        try:
            # Try to use jenkspy if available
            import jenkspy
            breaks = jenkspy.jenks_breaks(values, nb_class=num_classes)
        except ImportError:
            # Fallback to quantiles if jenkspy not available
            st.warning("üìä Quebras Naturais n√£o dispon√≠vel - usando Quantiles como alternativa")
            percentiles = np.linspace(0, 100, num_classes + 1)
            breaks = np.percentile(values, percentiles)
            
    elif method == "Desvio Padr√£o":
        # Standard deviation breaks
        mean_val = values.mean()
        std_val = values.std()
        
        # Create breaks around the mean using standard deviations
        half_classes = num_classes // 2
        breaks = []
        
        for i in range(-half_classes, half_classes + 1):
            breaks.append(mean_val + i * std_val)
        
        # Ensure we have the right number of breaks and they're within data range
        breaks = np.array(breaks)
        breaks = np.clip(breaks, values.min(), values.max())
        breaks = sorted(set(breaks))  # Remove duplicates and sort
        
        # Adjust if we don't have enough breaks
        while len(breaks) < num_classes + 1:
            breaks.append(values.max())
        breaks = breaks[:num_classes + 1]
    
    return sorted(set(breaks))  # Remove duplicates and sort

def apply_normalization(df, base_col, normalization_type):
    """Apply data normalization based on user selection"""
    df_norm = df.copy()
    
    if normalization_type == "Potencial Absoluto (Nm¬≥/ano)":
        # No normalization - use original values
        return df_norm, base_col
        
    elif normalization_type == "Potencial per Capita (Nm¬≥/hab/ano)":
        # Normalize by population
        if 'populacao_2022' in df_norm.columns:
            normalized_col = f"{base_col}_per_capita"
            df_norm[normalized_col] = df_norm[base_col] / df_norm['populacao_2022'].replace(0, 1)  # Avoid division by zero
            df_norm[normalized_col] = df_norm[normalized_col].fillna(0)
            return df_norm, normalized_col
        else:
            st.warning("‚ö†Ô∏è Dados populacionais n√£o dispon√≠veis para normaliza√ß√£o per capita")
            return df_norm, base_col
            
    elif normalization_type == "Potencial por √Årea (Nm¬≥/km¬≤/ano)":
        # Normalize by area
        if 'area_km2' in df_norm.columns:
            normalized_col = f"{base_col}_per_area"
            df_norm[normalized_col] = df_norm[base_col] / df_norm['area_km2'].replace(0, 1)  # Avoid division by zero
            df_norm[normalized_col] = df_norm[normalized_col].fillna(0)
            return df_norm, normalized_col
        else:
            st.warning("‚ö†Ô∏è Dados de √°rea n√£o dispon√≠veis para normaliza√ß√£o por √°rea")
            return df_norm, base_col
            
    elif normalization_type == "Densidade Populacional (hab/km¬≤)":
        # Show population density instead of biogas potential
        if 'populacao_2022' in df_norm.columns and 'area_km2' in df_norm.columns:
            density_col = "densidade_populacional"
            df_norm[density_col] = df_norm['populacao_2022'] / df_norm['area_km2'].replace(0, 1)
            df_norm[density_col] = df_norm[density_col].fillna(0)
            return df_norm, density_col
        else:
            st.warning("‚ö†Ô∏è Dados populacionais ou de √°rea n√£o dispon√≠veis para densidade populacional")
            return df_norm, base_col
    
    return df_norm, base_col

def apply_filters(df, filters):
    """
    Apply filters to dataframe - ALWAYS returns all 645 municipalities.
    Only changes the display column for visualization.
    """
    if df.empty:
        return df, 'total_final_nm_ano'
    
    # Always work with a full copy of the dataframe
    df_to_display = df.copy()
    
    # Calculate display column based on residue selection
    if not filters['residues']:
        # Default case if nothing is selected
        display_col = 'total_final_nm_ano'
        df_to_display['display_col'] = 0
    elif len(filters['residues']) == 1:
        display_col = filters['residues'][0]
    else:
        display_col = 'combined_potential'
        available_residues = [col for col in filters['residues'] if col in df_to_display.columns]
        if available_residues:
            df_to_display[display_col] = df_to_display[available_residues].fillna(0).sum(axis=1)
        else:
            df_to_display[display_col] = 0
    
    # Apply normalization if specified
    if 'normalization' in filters and filters['normalization'] != "Potencial Absoluto (Nm¬≥/ano)":
        df_to_display, display_col = apply_normalization(df_to_display, display_col, filters['normalization'])
            
    return df_to_display, display_col

# Map functions
@st.cache_data(ttl=3600)  # Cache for 1 hour
def load_optimized_geometries(detail_level="medium_detail"):
    """Load optimized municipality geometries from GeoParquet"""
    import geopandas as gpd
    from pathlib import Path
    
    try:
        parquet_path = Path(__file__).parent.parent.parent / "shapefile" / f"municipalities_{detail_level}.parquet"
        
        if parquet_path.exists():
            return gpd.read_parquet(parquet_path)
        else:
            # Fallback to original shapefile
            shapefile_path = Path(__file__).parent.parent.parent / "shapefile" / "Municipios_SP_shapefile.shp"
            if shapefile_path.exists():
                gdf = gpd.read_file(shapefile_path)
                if gdf.crs != 'EPSG:4326':
                    gdf = gdf.to_crs('EPSG:4326')
                gdf['cd_mun'] = gdf['CD_MUN'].astype(str)
                return gdf
    except Exception as e:
        st.error(f"Error loading geometries: {e}")
    
    return None

def create_centroid_map(df, display_col, filters=None, get_legend_only=False, search_term="", viz_type="C√≠rculos Proporcionais", show_mapbiomas_layer=False, show_rios=False, show_rodovias=False, show_plantas_biogas=False, show_gasodutos_dist=False, show_gasodutos_transp=False, show_areas_urbanas=False, show_regioes_admin=False):
    """Create folium map with weighted centroids and floating controls"""
    import geopandas as gpd
    from pathlib import Path
    import numpy as np
    
    try:
        # --- CLEAN LIGHT BASEMAP SETUP ---
        m = folium.Map(
            location=[-22.5, -48.5], 
            zoom_start=7,
            tiles='CartoDB positron'  # Clean light basemap
        )
        
        # Add only clean, professional basemap options with proper attribution
        folium.TileLayer(
            tiles='OpenStreetMap',
            name='OpenStreetMap',
            attr='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        ).add_to(m)
        folium.TileLayer(
            tiles='Stamen Terrain',
            name='Terreno', 
            attr='Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.'
        ).add_to(m)
        # Dark mode basemap removed completely
        # ------------------------------------
        
        # --- CAMADA MAPBIOMAS COM RASTER OTIMIZADO ---
        if show_mapbiomas_layer:
            if not HAS_RASTER_SYSTEM:
                st.info("üìÅ Sistema MapBiomas n√£o dispon√≠vel - instale as depend√™ncias rasterio e matplotlib")
                return m, ""
                
            try:
                # Verificar se o caminho do raster existe ANTES de tentar usar
                project_root = Path(__file__).parent.parent.parent
                raster_dir = project_root / "rasters"
                
                if not raster_dir.exists():
                    st.info("üìÅ Pasta 'rasters' n√£o encontrada - funcionalidade MapBiomas desabilitada")
                    return m, ""
                    
                raster_loader = RasterLoader(str(raster_dir))
                
                # Lista rasters dispon√≠veis
                available_rasters = raster_loader.list_available_rasters()
                mapbiomas_rasters = [r for r in available_rasters if 'mapbiomas' in r.lower() or 'agropecuaria' in r.lower()]
                
                if mapbiomas_rasters:
                    # Usa o primeiro raster encontrado
                    raster_path = mapbiomas_rasters[0]
                    data, metadata = raster_loader.load_raster(raster_path)
                    
                    if data is not None and metadata is not None:
                        # Cria sobreposi√ß√£o para o Folium
                        overlay = raster_loader.raster_to_folium_overlay(data, metadata, opacity=0.7)
                        
                        if overlay is not None:
                            # Cria FeatureGroup para controle de camadas
                            mapbiomas_group = folium.FeatureGroup(name="MapBiomas - Agropecu√°ria SP", show=True)
                            overlay.add_to(mapbiomas_group)
                            mapbiomas_group.add_to(m)
                            
                            # Adiciona legenda
                            legend_html = create_mapbiomas_legend()
                            m.get_root().html.add_child(folium.Element(legend_html))
                            
                        else:
                            st.warning("‚ö†Ô∏è Erro ao processar raster para visualiza√ß√£o")
                    else:
                        st.warning("‚ö†Ô∏è Erro ao carregar dados do raster")
                else:
                    st.info("üìÅ Nenhum arquivo raster MapBiomas encontrado na pasta 'rasters/'")
                    st.info("üí° Baixe o GeoTIFF do Google Earth Engine e coloque na pasta 'rasters/'")
                    
            except ImportError as e:
                st.error("‚ùå Sistema de rasters n√£o dispon√≠vel. Instale as depend√™ncias: pip install rasterio matplotlib")
            except Exception as e:
                st.warning(f"‚ö†Ô∏è Erro ao carregar camada MapBiomas: {str(e)}")
        
        # Add S√£o Paulo state borders first (background) - ALWAYS SHOW
        try:
            sp_border_path = Path(__file__).parent.parent.parent / "shapefile" / "Limite_SP.shp"
            if sp_border_path.exists():
                sp_border = gpd.read_file(sp_border_path)
                if sp_border.crs != 'EPSG:4326':
                    sp_border = sp_border.to_crs('EPSG:4326')
                
                folium.GeoJson(
                    sp_border,
                    style_function=lambda x: {
                        'fillColor': 'rgba(46, 139, 87, 0.1)',
                        'color': '#2E8B57',
                        'weight': 2,
                        'opacity': 0.8,
                        'fillOpacity': 0.1,
                        'dashArray': '5, 5'
                    },
                    tooltip='Estado de S√£o Paulo',
                    interactive=False  # Make state border non-interactive
                ).add_to(m)
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Bordas do estado: {e}")
        
        if df.empty:
            # Layer Control removed - now using Streamlit checkboxes
            return m, ""  # Return map and empty legend string
        
        # --- CAMADAS DE REFER√äNCIA COM FEATUREGROUP ---
        # Camada de rodovias estaduais
        if show_rodovias:
            try:
                rodovias_group = folium.FeatureGroup(name="Rodovias Estaduais", show=True)
                rodovias_path = Path(__file__).parent.parent.parent / "shapefile" / "Rodovias_Estaduais_SP.shp"
                if rodovias_path.exists():
                    rodovias_gdf = gpd.read_file(rodovias_path)
                    folium.GeoJson(
                        rodovias_gdf,
                        style_function=lambda feature: {
                            'fillColor': 'transparent',
                            'color': '#FF4500',
                            'weight': 2,
                            'opacity': 0.8,
                            'fillOpacity': 0
                        },
                        tooltip="Rodovia Estadual",
                        popup="Rodovias Estaduais de S√£o Paulo"
                    ).add_to(rodovias_group)
                    rodovias_group.add_to(m)
                    print("[SUCESSO] Camada de rodovias (FeatureGroup) adicionada.")
            except Exception as e:
                print(f"[ERRO] Erro ao carregar rodovias: {e}")
        
        # Camada de rios principais (estrutura preparada para futuro)
        if show_rios:
            try:
                rios_group = folium.FeatureGroup(name="Rios Principais", show=True)
                rios_path = Path(__file__).parent.parent.parent / "shapefile" / "Rios_Principais_SP.shp"
                if rios_path.exists():
                    rios_gdf = gpd.read_file(rios_path)
                    folium.GeoJson(
                        rios_gdf,
                        style_function=lambda feature: {
                            'fillColor': 'transparent',
                            'color': '#4169E1',
                            'weight': 2,
                            'opacity': 0.8,
                            'fillOpacity': 0
                        },
                        tooltip="Rio Principal",
                        popup="Rios Principais de S√£o Paulo"
                    ).add_to(rios_group)
                    rios_group.add_to(m)
                    print("[SUCESSO] Camada de rios (FeatureGroup) adicionada.")
                else:
                    print("[INFO] Shapefile de rios n√£o encontrado - funcionalidade preparada para futuro.")
            except Exception as e:
                print(f"[ERRO] Erro ao carregar rios: {e}")
        
        # --- CAMADAS DE INFRAESTRUTURA DE BIOG√ÅS ---
        # Camada de plantas de biog√°s
        if show_plantas_biogas:
            try:
                st.write("üîç **PROCESSANDO:** Plantas de Biog√°s...")
                plantas_group = folium.FeatureGroup(name="üè≠ Plantas de Biog√°s", show=True)
                plantas_path = Path(__file__).parent.parent.parent / "shapefile" / "Plantas_Biogas_SP.shp"
                st.write(f"üìÅ Caminho: {plantas_path}")
                st.write(f"‚úÖ Arquivo existe: {plantas_path.exists()}")
                if plantas_path.exists():
                    plantas_gdf = gpd.read_file(plantas_path)
                    st.write(f"üìä Registros carregados: {len(plantas_gdf)}")
                    
                    # Converter para WGS84 se necess√°rio
                    if plantas_gdf.crs and plantas_gdf.crs != 'EPSG:4326':
                        st.write(f"üîÑ Convertendo CRS de {plantas_gdf.crs} para EPSG:4326...")
                        plantas_gdf = plantas_gdf.to_crs('EPSG:4326')
                        st.write("‚úÖ Convers√£o de CRS conclu√≠da")
                    
                    # Definir cores por tipo de planta
                    def get_plant_color(tipo_plant):
                        color_map = {
                            'Biog√°s': '#32CD32',
                            'Aterro Sanit√°rio': '#8B4513',
                            'Esta√ß√£o de Tratamento': '#4169E1',
                            'Suinocultura': '#FF69B4',
                            'Agropecu√°ria': '#228B22',
                            'Industrial': '#FF4500',
                            'Outros': '#9370DB'
                        }
                        return color_map.get(tipo_plant, '#666666')
                    
                    st.write("üéØ Adicionando pontos ao mapa...")
                    pontos_adicionados = 0
                    
                    for idx, row in plantas_gdf.iterrows():
                        try:
                            tipo_plant = row.get('TIPO_PLANT', 'N√£o informado')
                            subtipo = row.get('SUBTIPO', 'N√£o informado')
                            status = row.get('STATUS', 'N√£o informado')
                            
                            # Extrair coordenadas
                            lat = row.geometry.y
                            lon = row.geometry.x
                            
                            # Verificar se as coordenadas s√£o v√°lidas (dentro do Brasil/SP)
                            if not (-35 <= lat <= -19 and -55 <= lon <= -44):
                                st.write(f"‚ö†Ô∏è Coordenadas inv√°lidas no ponto {idx}: lat={lat:.6f}, lon={lon:.6f}")
                                continue
                            
                            popup_text = f"""
                            <b>üè≠ Planta de Biog√°s</b><br>
                            <b>Tipo:</b> {tipo_plant}<br>
                            <b>Subtipo:</b> {subtipo}<br>
                            <b>Status:</b> {status}<br>
                            <b>Coords:</b> {lat:.6f}, {lon:.6f}
                            """
                            
                            folium.CircleMarker(
                                location=[lat, lon],
                                radius=8,
                                popup=folium.Popup(popup_text, max_width=250),
                                tooltip=f"Planta: {tipo_plant} - {subtipo}",
                                color='#000000',
                                fillColor=get_plant_color(tipo_plant),
                                fillOpacity=0.8,
                                weight=2
                            ).add_to(plantas_group)
                            pontos_adicionados += 1
                            
                        except Exception as e:
                            st.write(f"‚ùå Erro no ponto {idx}: {e}")
                            continue
                    
                    st.write(f"‚úÖ {pontos_adicionados} pontos adicionados de {len(plantas_gdf)} totais")
                    
                    plantas_group.add_to(m)
                    st.success(f"‚úÖ **SUCESSO:** Camada de plantas de biog√°s adicionada: {len(plantas_gdf)} plantas.")
                    print(f"[SUCESSO] Camada de plantas de biog√°s adicionada: {len(plantas_gdf)} plantas.")
                else:
                    print("[ERRO] Shapefile de plantas de biog√°s n√£o encontrado.")
            except Exception as e:
                print(f"[ERRO] Erro ao carregar plantas de biog√°s: {e}")
        
        # Camada de gasodutos - distribui√ß√£o
        if show_gasodutos_dist:
            try:
                gasodutos_dist_group = folium.FeatureGroup(name="‚õΩ Gasodutos - Distribui√ß√£o", show=True)
                gasodutos_path = Path(__file__).parent.parent.parent / "shapefile" / "Gasodutos_Distribuicao_SP.shp"
                if gasodutos_path.exists():
                    gasodutos_gdf = gpd.read_file(gasodutos_path)
                    folium.GeoJson(
                        gasodutos_gdf,
                        style_function=lambda feature: {
                            'color': '#FF6600',
                            'weight': 3,
                            'opacity': 0.8,
                            'dashArray': '5, 5'
                        },
                        tooltip="Gasoduto de Distribui√ß√£o",
                        popup="Rede de Distribui√ß√£o de G√°s Natural"
                    ).add_to(gasodutos_dist_group)
                    gasodutos_dist_group.add_to(m)
                    print(f"[SUCESSO] Camada de gasodutos de distribui√ß√£o adicionada: {len(gasodutos_gdf)} trechos.")
                else:
                    print("[ERRO] Shapefile de gasodutos de distribui√ß√£o n√£o encontrado.")
            except Exception as e:
                print(f"[ERRO] Erro ao carregar gasodutos de distribui√ß√£o: {e}")
        
        # Camada de gasodutos - transporte
        if show_gasodutos_transp:
            try:
                gasodutos_transp_group = folium.FeatureGroup(name="‚õΩ Gasodutos - Transporte", show=True)
                gasodutos_path = Path(__file__).parent.parent.parent / "shapefile" / "Gasodutos_Transporte_SP.shp"
                if gasodutos_path.exists():
                    gasodutos_gdf = gpd.read_file(gasodutos_path)
                    folium.GeoJson(
                        gasodutos_gdf,
                        style_function=lambda feature: {
                            'color': '#CC0000',
                            'weight': 4,
                            'opacity': 0.9,
                            'dashArray': '10, 5'
                        },
                        tooltip="Gasoduto de Transporte",
                        popup=folium.GeoJsonPopup(fields=['Nome_Dut_1', 'MUNIC_ORIG', 'MUNIC_DEST'], 
                                                labels=['Nome:', 'Origem:', 'Destino:'])
                    ).add_to(gasodutos_transp_group)
                    gasodutos_transp_group.add_to(m)
                    print(f"[SUCESSO] Camada de gasodutos de transporte adicionada: {len(gasodutos_gdf)} trechos.")
                else:
                    print("[ERRO] Shapefile de gasodutos de transporte n√£o encontrado.")
            except Exception as e:
                print(f"[ERRO] Erro ao carregar gasodutos de transporte: {e}")
        
        # --- √ÅREAS URBANAS LAYER (FROM GEOPARQUET) ---
        if show_areas_urbanas:
            try:
                areas_group = folium.FeatureGroup(name="üèòÔ∏è √Åreas Urbanas", show=True)
                areas_path = Path(__file__).parent.parent.parent / "geoparquet" / "Areas_Urbanas_SP.parquet"
                if areas_path.exists():
                    areas_gdf = gpd.read_parquet(areas_path)
                    folium.GeoJson(
                        areas_gdf,
                        style_function=lambda feature: {
                            'color': '#8B4513',
                            'weight': 1,
                            'opacity': 0.7,
                            'fillColor': '#DEB887',
                            'fillOpacity': 0.3
                        },
                        tooltip="√Årea Urbana",
                        popup=folium.GeoJsonPopup(fields=['QAREA'], 
                                                labels=['√Årea (ha):'])
                    ).add_to(areas_group)
                    areas_group.add_to(m)
                    print(f"[SUCESSO] Camada de √°reas urbanas adicionada: {len(areas_gdf)} pol√≠gonos.")
                else:
                    print("[ERRO] Arquivo GeoParquet de √°reas urbanas n√£o encontrado.")
            except Exception as e:
                print(f"[ERRO] Erro ao carregar √°reas urbanas: {e}")
        
        # --- REGI√ïES ADMINISTRATIVAS LAYER ---
        if show_regioes_admin:
            try:
                regioes_group = folium.FeatureGroup(name="üèõÔ∏è Regi√µes Administrativas", show=True)
                regioes_path = Path(__file__).parent.parent.parent / "shapefile" / "Regiao_Adm_SP.shp"
                if regioes_path.exists():
                    regioes_gdf = gpd.read_file(regioes_path)
                    # Define colors for different regions
                    colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', 
                             '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43',
                             '#10AC84', '#EE5A24', '#0984E3', '#A29BFE', '#FD79A8', '#E84393']
                    
                    for idx, row in regioes_gdf.iterrows():
                        color = colors[idx % len(colors)]
                        folium.GeoJson(
                            row.geometry,
                            style_function=lambda feature, color=color: {
                                'color': color,
                                'weight': 2,
                                'opacity': 0.8,
                                'fillColor': color,
                                'fillOpacity': 0.2
                            },
                            tooltip=f"Regi√£o: {row['Nome']}",
                            popup=folium.GeoJsonPopup(fields=[row['Nome']], 
                                                    labels=['Regi√£o:'])
                        ).add_to(regioes_group)
                    
                    regioes_group.add_to(m)
                    print(f"[SUCESSO] Camada de regi√µes administrativas adicionada: {len(regioes_gdf)} regi√µes.")
                else:
                    print("[ERRO] Shapefile de regi√µes administrativas n√£o encontrado.")
            except Exception as e:
                print(f"[ERRO] Erro ao carregar regi√µes administrativas: {e}")
        # ------------------------------------------
        
        # Load municipality centroids
        try:
            centroid_path = Path(__file__).parent.parent.parent / "shapefile" / "municipality_centroids.parquet"
            
            if not centroid_path.exists():
                st.warning("‚ö†Ô∏è Centroids file not found")
                return m
                
            import pandas as pd
            centroids_df = pd.read_parquet(centroid_path)
            
            # Convert to geopandas
            if 'geometry' in centroids_df.columns:
                centroids_gdf = gpd.GeoDataFrame(centroids_df)
            elif 'lat' in centroids_df.columns and 'lon' in centroids_df.columns:
                from shapely.geometry import Point
                centroids_df['geometry'] = centroids_df.apply(lambda row: Point(row['lon'], row['lat']), axis=1)
                centroids_gdf = gpd.GeoDataFrame(centroids_df, geometry='geometry')
            else:
                st.warning("‚ö†Ô∏è No coordinate data in centroids")
                return m
            
            # Merge with biogas data
            df_merged = centroids_gdf.merge(df, on='cd_mun', how='inner', suffixes=('_geo', ''))
            
            if df_merged.empty:
                st.warning("‚ö†Ô∏è No municipalities matched")
                return m
            
            # Ensure municipality name
            if 'nome_municipio' not in df_merged.columns:
                if 'NM_MUN' in df_merged.columns:
                    df_merged['nome_municipio'] = df_merged['NM_MUN']
                elif 'nome_municipio_geo' in df_merged.columns:
                    df_merged['nome_municipio'] = df_merged['nome_municipio_geo']
            
            # Calculate circle sizes
            max_val = float(df_merged[display_col].max())
            min_val = float(df_merged[display_col].min())
            
            if max_val == min_val or max_val == 0:
                df_merged['circle_size'] = 8
            else:
                normalized = (df_merged[display_col] - min_val) / (max_val - min_val)
                df_merged['circle_size'] = 3 + 22 * normalized
            
            df_merged['circle_size'] = df_merged['circle_size'].fillna(8)
            
            # Color mapping
            def get_color(value):
                if max_val == min_val:
                    return '#7fcdbb'
                normalized = (value - min_val) / (max_val - min_val)
                if normalized < 0.2:
                    return '#ffffcc'
                elif normalized < 0.4:
                    return '#c7e9b4'
                elif normalized < 0.6:
                    return '#7fcdbb'
                elif normalized < 0.8:
                    return '#41b6c4'
                else:
                    return '#253494'
            
            # Clean data for visualization, removing rows with no potential or no location
            df_viz = df_merged.copy()
            df_viz = df_viz[df_viz[display_col] > 0]  # Remove zero values
            
            # --- RENDER VISUALIZATION BASED ON USER CHOICE ---
            
            if viz_type == "C√≠rculos Proporcionais":
                # Original circle marker visualization
                for idx, row in df_viz.iterrows():
                    try:
                        if hasattr(row['geometry'], 'y') and hasattr(row['geometry'], 'x'):
                            lat, lon = float(row['geometry'].y), float(row['geometry'].x)
                        elif 'lat' in row and 'lon' in row:
                            lat, lon = float(row['lat']), float(row['lon'])
                        else:
                            continue
                    except (AttributeError, TypeError, ValueError):
                        continue
                    
                    # --- EMBED THE UNIQUE ID IN THE POPUP ---
                    popup_text = f"""
                    <!-- id:{row['cd_mun']} -->
                    <b>{row['nome_municipio']}</b><br>
                    {display_col.replace('_', ' ').title()}: {row[display_col]:,.0f} Nm¬≥/ano
                    """
                    
                    # The tooltip remains clean
                    tooltip_text = f"{row['nome_municipio']}: {row[display_col]:,.0f} Nm¬≥/ano"
                    
                    # Check if this municipality matches the search term
                    is_searched = (search_term and 
                                  search_term.lower() in row['nome_municipio'].lower())
                    
                    folium.CircleMarker(
                        location=[lat, lon],
                        radius=row['circle_size'] * 1.5 if is_searched else row['circle_size'],
                        popup=popup_text,
                        tooltip=f"{'[BUSCA] ' if is_searched else ''}{tooltip_text}",
                        color='red' if is_searched else 'black',
                        weight=3 if is_searched else 1,
                        fillColor='red' if is_searched else get_color(row[display_col]),
                        fillOpacity=0.9 if is_searched else 0.7
                    ).add_to(m)

            elif viz_type == "Mapa de Calor (Heatmap)":
                # Enhanced Heatmap visualization with intelligent radius calculation
                heat_data = []
                values = []
                
                # Collect data and values for analysis
                for idx, row in df_viz.iterrows():
                    try:
                        if hasattr(row['geometry'], 'y') and hasattr(row['geometry'], 'x'):
                            lat, lon = float(row['geometry'].y), float(row['geometry'].x)
                        elif 'lat' in row and 'lon' in row:
                            lat, lon = float(row['lat']), float(row['lon'])
                        else:
                            continue
                        
                        value = float(row[display_col])
                        heat_data.append([lat, lon, value])
                        values.append(value)
                    except (AttributeError, TypeError, ValueError):
                        continue
                
                if heat_data and values:
                    # Calculate balanced heatmap with outlier handling
                    import numpy as np
                    values_array = np.array(values)
                    
                    # Data analysis
                    data_count = len(values_array)
                    data_min = np.min(values_array)
                    data_max = np.max(values_array)
                    data_median = np.median(values_array)
                    data_q75 = np.percentile(values_array, 75)
                    data_q25 = np.percentile(values_array, 25)
                    
                    # Handle extreme outliers by using percentile-based scaling
                    # Use 95th percentile as effective max to prevent over-concentration
                    effective_max = np.percentile(values_array, 95)
                    effective_min = np.percentile(values_array, 5)
                    
                    # Normalize values using effective range to reduce outlier impact
                    normalized_heat_data = []
                    for lat, lon, value in heat_data:
                        # Cap extreme values
                        capped_value = min(max(value, effective_min), effective_max)
                        # Normalize to 0-1 range using effective range
                        if effective_max > effective_min:
                            normalized_value = (capped_value - effective_min) / (effective_max - effective_min)
                        else:
                            normalized_value = 0.5
                        
                        # Apply square root transformation to reduce concentration of high values
                        balanced_value = np.sqrt(normalized_value)
                        
                        normalized_heat_data.append([lat, lon, balanced_value])
                    
                    # Calculate radius based on data distribution characteristics
                    base_radius = 18
                    
                    # Factor 1: Data spread using IQR (more robust than std)
                    iqr = data_q75 - data_q25
                    spread_ratio = iqr / data_median if data_median > 0 else 1
                    spread_factor = min(1.8, max(0.7, spread_ratio))
                    
                    # Factor 2: Data density
                    if data_count > 400:
                        density_factor = 0.8  # Many points = smaller radius
                    elif data_count > 200:
                        density_factor = 1.0  # Medium points = normal radius
                    else:
                        density_factor = 1.2  # Few points = larger radius
                    
                    # Factor 3: Value distribution
                    outlier_ratio = (data_max - effective_max) / (data_max - data_min) if data_max > data_min else 0
                    if outlier_ratio > 0.3:  # Many outliers
                        distribution_factor = 0.9
                    else:  # Normal distribution
                        distribution_factor = 1.1
                    
                    # Calculate final parameters
                    final_radius = int(base_radius * spread_factor * density_factor * distribution_factor)
                    final_radius = max(12, min(28, final_radius))  # Constrain to reasonable range
                    
                    # Blur should be smaller relative to radius for better definition
                    final_blur = max(6, int(final_radius * 0.5))
                    
                    # Balanced gradient that shows both low and high values well
                    balanced_gradient = {
                        0.0: '#000080',   # Dark blue - very low
                        0.15: '#0040FF',  # Blue - low  
                        0.3: '#0080FF',   # Light blue - low-medium
                        0.45: '#00FFFF',  # Cyan - medium-low
                        0.6: '#40FF40',   # Light green - medium
                        0.75: '#FFFF00',  # Yellow - medium-high
                        0.85: '#FF8000',  # Orange - high
                        0.95: '#FF4000',  # Red-orange - very high
                        1.0: '#FF0000'    # Red - maximum
                    }
                    
                    # Create balanced heatmap
                    HeatMap(
                        normalized_heat_data,
                        radius=final_radius,
                        blur=final_blur,
                        max_zoom=1,
                        gradient=balanced_gradient,
                        min_opacity=0.3,
                        max_zoom_level=18
                    ).add_to(m)
                    
                    # Debug info
                    print(f"Balanced Heatmap - Radius: {final_radius}, Blur: {final_blur}")
                    print(f"Original range: {data_min:,.0f} - {data_max:,.0f}")
                    print(f"Effective range: {effective_min:,.0f} - {effective_max:,.0f}")
                    print(f"Median: {data_median:,.0f}, IQR: {iqr:,.0f}")

            elif viz_type == "Agrupamentos (Clusters)":
                # Marker clustering visualization
                marker_cluster = MarkerCluster().add_to(m)
                
                for idx, row in df_viz.iterrows():
                    try:
                        if hasattr(row['geometry'], 'y') and hasattr(row['geometry'], 'x'):
                            lat, lon = float(row['geometry'].y), float(row['geometry'].x)
                        elif 'lat' in row and 'lon' in row:
                            lat, lon = float(row['lat']), float(row['lon'])
                        else:
                            continue
                    except (AttributeError, TypeError, ValueError):
                        continue
                    
                    # --- EMBED THE UNIQUE ID IN THE POPUP FOR CLUSTERS TOO ---
                    popup_text = f"""
                    <!-- id:{row['cd_mun']} -->
                    <b>{row['nome_municipio']}</b><br>
                    {display_col.replace('_', ' ').title()}: {row[display_col]:,.0f} Nm¬≥/ano<br>
                    <small>Posi√ß√£o: {lat:.4f}, {lon:.4f}</small>
                    """
                    
                    # Check if this municipality matches the search term
                    is_searched = (search_term and 
                                  search_term.lower() in row['nome_municipio'].lower())
                    
                    # Use different icon for searched municipalities
                    icon = folium.Icon(color='red', icon='search') if is_searched else folium.Icon(color='green', icon='leaf')
                    
                    folium.Marker(
                        location=[lat, lon],
                        popup=popup_text,
                        tooltip=f"{'[BUSCA] ' if is_searched else ''}{row['nome_municipio']}: {row[display_col]:,.0f}",
                        icon=icon
                    ).add_to(marker_cluster)

            elif viz_type == "Mapa de Preenchimento (Coropl√©tico)":
                # Choropleth visualization using municipality boundaries
                try:
                    # Load optimized polygon geometries
                    gdf = load_optimized_geometries("medium_detail")
                    
                    if gdf is not None:
                        # Merge data with geometries
                        df_choropleth = gdf.merge(df_viz, on='cd_mun', how='inner')
                        
                        if not df_choropleth.empty:
                            # Prepare data for choropleth
                            choropleth_data = df_choropleth[['cd_mun', display_col]].dropna()
                            
                            # Create choropleth layer
                            folium.Choropleth(
                                geo_data=df_choropleth.to_json(),
                                name='Potencial de Biog√°s',
                                data=choropleth_data,
                                columns=['cd_mun', display_col],
                                key_on='feature.properties.cd_mun',
                                fill_color='YlOrRd',
                                fill_opacity=0.7,
                                line_opacity=0.3,
                                line_color='black',
                                line_weight=0.5,
                                legend_name=f'Potencial (Nm¬≥/ano)',
                                highlight=True,
                                smooth_factor=0.5
                            ).add_to(m)
                            
                            # Add interactive popups for each municipality
                            for idx, row in df_choropleth.iterrows():
                                # Create popup with embedded ID for selection
                                popup_text = f"""
                                <!-- id:{row['cd_mun']} -->
                                <b>{row.get('nome_municipio', 'Munic√≠pio')}</b><br>
                                {display_col.replace('_', ' ').title()}: {row[display_col]:,.0f} Nm¬≥/ano<br>
                                <small>C√≥digo: {row['cd_mun']}</small>
                                """
                                
                                # Calculate centroid of the polygon for popup placement
                                if hasattr(row['geometry'], 'centroid'):
                                    centroid = row['geometry'].centroid
                                    popup_lat, popup_lon = centroid.y, centroid.x
                                    
                                    # Add invisible marker for click detection
                                    folium.Marker(
                                        location=[popup_lat, popup_lon],
                                        popup=popup_text,
                                        tooltip=f"{row.get('nome_municipio', 'Munic√≠pio')}: {row[display_col]:,.0f}",
                                        icon=folium.DivIcon(html="", icon_size=(1, 1), icon_anchor=(0, 0))
                                    ).add_to(m)
                        else:
                            st.warning("‚ö†Ô∏è N√£o foi poss√≠vel combinar dados com geometrias para visualiza√ß√£o coropl√©tica")
                    else:
                        st.warning("‚ö†Ô∏è Geometrias otimizadas n√£o encontradas para visualiza√ß√£o coropl√©tica")
                        
                except Exception as e:
                    st.error(f"‚ùå Erro ao criar mapa coropl√©tico: {e}")
            
            # --- ADD CATCHMENT AREA VISUALIZATION ---
            if hasattr(st.session_state, 'catchment_center') and st.session_state.catchment_center:
                center_lat, center_lon = st.session_state.catchment_center
                radius_km = getattr(st.session_state, 'catchment_radius', 50)
                
                # Add center marker
                folium.Marker(
                    location=[center_lat, center_lon],
                    popup=f"Centro de Capta√ß√£o<br>Raio: {radius_km}km",
                    tooltip=f"Centro de Capta√ß√£o ({radius_km}km)",
                    icon=folium.Icon(color='red', icon='bullseye', prefix='fa')
                ).add_to(m)
                
                # Add radius circle
                folium.Circle(
                    location=[center_lat, center_lon],
                    radius=radius_km * 1000,  # Convert km to meters
                    popup=f"√Årea de Capta√ß√£o: {radius_km}km",
                    color='red',
                    weight=2,
                    fill=True,
                    fillColor='red',
                    fillOpacity=0.1
                ).add_to(m)
            
            # --- NEW MAP CONTROLS ---
            # 1. Add Mini Map (overview map)
            minimap = MiniMap(toggle_display=True, position='bottomright')
            minimap.add_to(m)
            
            # 2. Layer Control removed - now using Streamlit checkboxes
            # -----------------------------------------
            
            # --- SIMPLIFIED LEGEND HTML for the Sidebar ---
            # No positioning or complex styling needed here. It will flow naturally in the sidebar.
            legend_html = f'''
            <div style="font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 13px;">
                <h4 style="margin-top: 0; margin-bottom: 12px; color: #2E8B57; text-align: center;">
                    üó∫Ô∏è Legenda do Mapa
                </h4>
                <div style="margin-bottom: 10px;">
                    <strong>üìä Dados:</strong> {display_col.replace('_', ' ').title()}
                </div>
                <div style="margin-bottom: 12px;">
                    <strong>üìà Faixa de Potencial:</strong><br>
                    Min: {df_merged[display_col].min():,.0f} Nm¬≥/ano<br>
                    Max: {df_merged[display_col].max():,.0f} Nm¬≥/ano
                </div>
                <div style="margin-bottom: 12px;">
                    <strong>üé® Escala de Cores:</strong><br>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #ffffcc; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>Muito Baixo</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #c7e9b4; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>Baixo</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #7fcdbb; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>M√©dio</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #41b6c4; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>Alto</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 2px 0;">
                        <div style="width: 15px; height: 15px; background-color: #253494; border: 1px solid #ccc; margin-right: 5px;"></div>
                        <span>Muito Alto</span>
                    </div>
                </div>
                <div>
                    <strong>üìè Tamanho do C√≠rculo:</strong><br>
                    <small>Proporcional ao potencial de biog√°s</small>
                </div>
            </div>
            '''
            
            # Check if only legend is requested
            if get_legend_only:
                return None, legend_html
            
            # --- REMOVED ---
            # m.get_root().html.add_child(folium.Element(legend_html))  <- REMOVE THIS LINE
            
        except Exception as e:
            st.error(f"‚ùå Error loading centroids: {e}")
            st.write(f"Debug: Exception details: {str(e)}")
        
        # Add floating legend to map - for circle and choropleth visualizations
        if viz_type in ["C√≠rculos Proporcionais", "Mapa de Preenchimento (Coropl√©tico)"]:
            legend_html_for_map = f'''
        <div style="position: fixed; 
                    top: 10px; right: 10px; width: 250px; height: auto; 
                    background-color: rgba(255, 255, 255, 0.95); 
                    border: 2px solid #2E8B57;
                    z-index:9999; font-size:12px; border-radius: 8px; padding: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    font-family: 'Segoe UI', Tahoma, sans-serif;">
            <h4 style="margin-top: 0; margin-bottom: 8px; color: #2E8B57; text-align: center; font-size: 14px;">
                üó∫Ô∏è Legenda
            </h4>
            <div style="margin-bottom: 8px; font-size: 11px;">
                <strong>üìä Dados:</strong> {display_col.replace('_', ' ').title()}
            </div>
            <div style="margin-bottom: 8px; font-size: 11px;">
                <strong>üìà Faixa:</strong><br>
                Min: {df_merged[display_col].min():,.0f}<br>
                Max: {df_merged[display_col].max():,.0f}
            </div>
            <div style="margin-bottom: 8px; font-size: 11px;">
                <strong>üé® Cores:</strong><br>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #ffffcc; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">Muito Baixo</span>
                </div>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #c7e9b4; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">Baixo</span>
                </div>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #7fcdbb; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">M√©dio</span>
                </div>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #41b6c4; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">Alto</span>
                </div>
                <div style="display: flex; align-items: center; margin: 1px 0;">
                    <div style="width: 12px; height: 12px; background-color: #253494; border: 1px solid #ccc; margin-right: 4px;"></div>
                    <span style="font-size: 10px;">Muito Alto</span>
                </div>
            </div>
            <div style="font-size: 10px;">
                <strong>üìè Tamanho:</strong> Proporcional ao potencial
            </div>
        </div>
        '''
        
            # Add the legend to the map
            m.get_root().html.add_child(folium.Element(legend_html_for_map))
        
        # --- VISUALIZA√á√ÉO DA AN√ÅLISE DE PROXIMIDADE ---
        if catchment_info and catchment_info.get("center"):
            center_lat, center_lon = catchment_info["center"]
            radius_km = catchment_info["radius"]
            
            # Adiciona o Pin (Marcador) no centro AO GRUPO
            folium.Marker(
                location=[center_lat, center_lon],
                popup=f"üìç Centro de An√°lise<br>Raio: {radius_km} km<br>Lat: {center_lat:.4f}<br>Lon: {center_lon:.4f}",
                tooltip="Centro da An√°lise de Proximidade",
                icon=folium.Icon(color='red', icon='crosshairs', prefix='fa')
            ).add_to(proximity_group)
            
            # Adiciona o C√≠rculo do Raio AO GRUPO
            folium.Circle(
                location=[center_lat, center_lon],
                radius=radius_km * 1000,  # folium.Circle usa metros
                color='#c93c3c',
                weight=2,
                fill=True,
                fill_color='#c93c3c',
                fill_opacity=0.15,
                popup=f"√Årea de An√°lise<br>Raio: {radius_km} km",
                tooltip=f"Raio de {radius_km} km"
            ).add_to(proximity_group)
        
        # NO FINAL DA FUN√á√ÉO, ANTES DO RETURN, adiciona o grupo ao mapa
        proximity_group.add_to(m)
        
        return m, legend_html
        
    except Exception as e:
        import traceback
        logger.error(f"Erro na cria√ß√£o do mapa: {e}")
        st.error(f"‚ùå Erro na cria√ß√£o do mapa: {e}")
        return folium.Map(location=[-22.5, -48.5], zoom_start=7), ""  # Return empty map/legend

def create_map(df, display_col, show_plantas_biogas=False, show_gasodutos_dist=False, show_gasodutos_transp=False, show_rios=False, show_rodovias=False, show_mapbiomas=False):
    """Create optimized folium map with municipality boundaries"""
    import geopandas as gpd
    from pathlib import Path
    
    # Center map on S√£o Paulo state
    m = folium.Map(
        location=[-22.5, -48.5], 
        zoom_start=7,
        tiles='OpenStreetMap',
        attr='OpenStreetMap'
    )
    
    if df.empty:
        return m
    
    try:
        # Load optimized geometries based on data size
        municipality_count = len(df)
        
        if municipality_count > 200:
            detail_level = "low_detail"  # Fast for large datasets
        elif municipality_count > 50:
            detail_level = "medium_detail"  # Balanced
        else:
            detail_level = "high_detail"  # Detailed for small datasets
        
        gdf = load_optimized_geometries(detail_level)
        
        if gdf is None:
            return create_simple_map(df, display_col)
        
        # Merge geometries with data
        df_merged = gdf.merge(df, on='cd_mun', how='inner', suffixes=('_geo', ''))
        
        if df_merged.empty:
            st.warning("‚ö†Ô∏è Nenhum munic√≠pio encontrado nos dados geom√©tricos.")
            return create_simple_map(df, display_col)
        
        # Ensure we have a consistent municipality name column
        if 'nome_municipio' not in df_merged.columns:
            if 'NM_MUN' in df_merged.columns:
                df_merged['nome_municipio'] = df_merged['NM_MUN']
            elif 'nome_municipio_geo' in df_merged.columns:
                df_merged['nome_municipio'] = df_merged['nome_municipio_geo']
        
        # Get value range for colors
        max_val = df_merged[display_col].max()
        min_val = df_merged[display_col].min()
        
        if max_val == min_val:
            max_val = min_val + 1
        
        # Create optimized GeoJson layer
        def style_function(feature):
            # Get municipality value
            cd_mun = feature['properties']['cd_mun']
            mun_data = df_merged[df_merged['cd_mun'] == cd_mun]
            
            if not mun_data.empty:
                value = mun_data.iloc[0][display_col]
                intensity = (value - min_val) / (max_val - min_val)
                
                if intensity > 0.8:
                    color = '#d73027'
                elif intensity > 0.6:
                    color = '#fc8d59'
                elif intensity > 0.4:
                    color = '#fee08b'
                elif intensity > 0.2:
                    color = '#d9ef8b'
                else:
                    color = '#91bfdb'
            else:
                color = '#cccccc'
            
            return {
                'fillColor': color,
                'color': 'black',
                'weight': 1,
                'fillOpacity': 0.7,
            }
        
        # Add optimized GeoJson layer
        folium.GeoJson(
            df_merged,
            style_function=style_function,
            popup=folium.GeoJsonPopup(
                fields=['nome_municipio', display_col],
                aliases=['Munic√≠pio:', 'Potencial:'],
                localize=True,
                labels=True,
                style="background-color: white;",
            ),
            tooltip=folium.GeoJsonTooltip(
                fields=['nome_municipio', display_col],
                aliases=['Munic√≠pio:', 'Potencial:'],
                localize=True,
                sticky=False,
                labels=True,
                style="""
                    background-color: #F0EFEF;
                    border: 2px solid black;
                    border-radius: 3px;
                    box-shadow: 3px;
                """,
                max_width=800,
            )
        ).add_to(m)
        
        # Add performance info
        st.info(f"üìä Renderizando {len(df_merged)} munic√≠pios com n√≠vel de detalhe: {detail_level}")
        
        return m
        
    except Exception as e:
        st.error(f"‚ùå Erro ao criar mapa: {e}")
        return create_simple_map(df, display_col)

def create_simple_map(df, display_col):
    """Fallback simple map creation"""
    m = folium.Map(location=[-22.5, -48.5], zoom_start=7)
    
    # Simple grid-based visualization as fallback
    import random
    random.seed(42)
    
    for idx, row in df.iterrows():
        intensity = random.uniform(0, 1)  # Simplified for fallback
        
        lat = -22.5 + random.uniform(-2, 2)
        lon = -48.5 + random.uniform(-4, 4)
        
        # Handle different municipality name columns
        muni_name = row.get('nome_municipio', row.get('NM_MUN', f'Munic√≠pio {idx}'))
        
        folium.CircleMarker(
            location=[lat, lon],
            radius=8,
            popup=f"<b>{muni_name}</b>",
            color='blue',
            fillColor='lightblue',
            fillOpacity=0.6
        ).add_to(m)
    
    return m

# Chart functions
def create_top_chart(df, display_col, title, limit=15):
    """Create top municipalities chart"""
    if df.empty:
        return None
    
    top_data = df.nlargest(limit, display_col)
    
    fig = px.bar(
        top_data,
        x='nome_municipio',
        y=display_col,
        title=f'Top {limit} Munic√≠pios - {title}',
        labels={display_col: 'Potencial (Nm¬≥/ano)', 'nome_municipio': 'Munic√≠pio'}
    )
    fig.update_layout(
        xaxis_tickangle=-45,
        height=400,
        showlegend=False
    )
    
    return fig

def create_distribution_chart(df, display_col, title):
    """Create distribution chart"""
    if df.empty:
        return None
    
    fig = px.histogram(
        df,
        x=display_col,
        title=f'Distribui√ß√£o - {title}',
        nbins=20,
        labels={display_col: 'Potencial (Nm¬≥/ano)'}
    )
    fig.update_layout(height=400)
    
    return fig

def create_correlation_chart(df, display_col, title):
    """Create a scatter plot to show correlation."""
    if df.empty or 'populacao_2022' not in df.columns:
        return None
    
    fig = px.scatter(
        df,
        x='populacao_2022',
        y=display_col,
        size=display_col,
        color=display_col,
        hover_name='nome_municipio',
        title=f'Popula√ß√£o vs Potencial - {title}',
        labels={'populacao_2022': 'Popula√ß√£o (2022)', display_col: 'Potencial (Nm¬≥/ano)'},
        color_continuous_scale='Viridis',
        size_max=60
    )
    fig.update_layout(height=400)
    return fig

# Page functions
def show_municipality_details_horizontal(df, municipality_id, selected_residues):
    """Show optimized horizontal layout for municipality details"""
    
    # Convert municipality_id and get data
    try:
        if municipality_id in df['cd_mun'].astype(str).values:
            mun_data = df[df['cd_mun'].astype(str) == str(municipality_id)].iloc[0]
        elif int(municipality_id) in df['cd_mun'].values:
            mun_data = df[df['cd_mun'] == int(municipality_id)].iloc[0]
        else:
            st.error(f"Munic√≠pio com ID {municipality_id} n√£o encontrado.")
            return
    except (ValueError, IndexError) as e:
        st.error(f"Erro ao encontrar munic√≠pio: {e}")
        return
    
    # Compact header
    st.markdown(f"""
    <div style='background: linear-gradient(135deg, #2E8B57 0%, #32CD32 100%); 
                color: white; padding: 0.8rem; border-radius: 8px; margin-bottom: 0.8rem;'>
        <div style='margin: 0; color: white; font-size: 1.1em; font-weight: bold;'>
            üìç {mun_data.get('regiao_imediata', 'N/A')}
        </div>
        <div style='margin: 2px 0 0 0; opacity: 0.9; font-size: 0.85em;'>
            üë• {mun_data.get('populacao_2022', 0):,.0f} hab | üìê {mun_data.get('area_km2', 0):.1f} km¬≤
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Key metrics in 2x2 grid
    total_potential = mun_data.get('total_final_nm_ano', 0)
    agri_potential = mun_data.get('total_agricola_nm_ano', 0)
    livestock_potential = mun_data.get('total_pecuaria_nm_ano', 0)
    urban_potential = mun_data.get('total_urbano_nm_ano', 0) if 'total_urbano_nm_ano' in mun_data else 0
    
    # Compact metrics grid
    col1, col2 = st.columns(2)
    with col1:
        st.metric("üéØ Total", f"{total_potential/1000000:.1f}M Nm¬≥/ano")
        st.metric("üåæ Agr√≠cola", f"{agri_potential/1000000:.1f}M Nm¬≥/ano")
    with col2:
        st.metric("üêÑ Pecu√°ria", f"{livestock_potential/1000000:.1f}M Nm¬≥/ano")
        st.metric("üèòÔ∏è Urbano", f"{urban_potential/1000000:.1f}M Nm¬≥/ano")
    
    # Compact visualization
    if total_potential > 0:
        st.markdown("**üèÜ Composi√ß√£o do Potencial:**")
        
        # Pie chart data
        main_categories = {
            'Agr√≠cola': agri_potential,
            'Pecu√°ria': livestock_potential,
            'Urbano': urban_potential
        }
        
        # Filter non-zero values
        main_categories = {k: v for k, v in main_categories.items() if v > 0}
        
        if main_categories:
            # Create compact pie chart
            fig = px.pie(
                values=list(main_categories.values()),
                names=list(main_categories.keys()),
                color_discrete_map={'Agr√≠cola': '#228B22', 'Pecu√°ria': '#8B4513', 'Urbano': '#4169E1'},
                height=250  # Compact height
            )
            fig.update_traces(textposition='inside', textinfo='percent+label')
            fig.update_layout(
                margin=dict(t=20, b=20, l=20, r=20),
                showlegend=False,
                font=dict(size=10)
            )
            st.plotly_chart(fig, width='stretch')
        
        # Top residue sources - compact list
        st.markdown("**üìã Principais Fontes:**")
        
        residue_sources = []
        for col in df.columns:
            if col.endswith('_nm_ano') and col not in ['total_final_nm_ano', 'total_agricola_nm_ano', 'total_pecuaria_nm_ano', 'total_urbano_nm_ano']:
                value = mun_data.get(col, 0)
                if value > 0:
                    clean_name = col.replace('_nm_ano', '').replace('_', ' ').title()
                    residue_sources.append((clean_name, value))
        
        # Sort and show top 5
        residue_sources.sort(key=lambda x: x[1], reverse=True)
        for i, (name, value) in enumerate(residue_sources[:5]):
            percentage = (value / total_potential) * 100
            st.markdown(f"**{i+1}.** {name}: {value/1000000:.2f}M Nm¬≥ ({percentage:.1f}%)")
        
        # Neighboring municipalities comparison chart
        if 'regiao_imediata' in mun_data.index and mun_data['regiao_imediata'] != 'N/A':
            st.markdown("---")
            st.markdown("**üèòÔ∏è Compara√ß√£o Regional:**")
            
            # Get municipalities in the same immediate region
            same_region = df[df['regiao_imediata'] == mun_data['regiao_imediata']].copy()
            
            if len(same_region) > 1:
                # Sort by total potential and get top 5 + current municipality
                same_region_sorted = same_region.nlargest(8, 'total_final_nm_ano')
                
                # Ensure current municipality is included
                if municipality_id not in same_region_sorted['cd_mun'].astype(str).values:
                    current_mun_row = same_region[same_region['cd_mun'].astype(str) == str(municipality_id)]
                    if not current_mun_row.empty:
                        same_region_sorted = pd.concat([same_region_sorted.head(7), current_mun_row])
                
                # Create comparison bar chart
                comparison_data = []
                for _, row in same_region_sorted.iterrows():
                    is_current = str(row['cd_mun']) == str(municipality_id)
                    comparison_data.append({
                        'Munic√≠pio': row['nome_municipio'][:15] + ('...' if len(row['nome_municipio']) > 15 else ''),
                        'Potencial': row['total_final_nm_ano'] / 1000000,
                        'Atual': is_current
                    })
                
                comparison_df = pd.DataFrame(comparison_data)
                
                # Create bar chart
                fig = px.bar(
                    comparison_df, 
                    x='Potencial', 
                    y='Munic√≠pio',
                    orientation='h',
                    color='Atual',
                    color_discrete_map={True: '#32CD32', False: '#87CEEB'},
                    height=250,
                    labels={'Potencial': 'Potencial (M Nm¬≥/ano)'}
                )
                fig.update_layout(
                    margin=dict(t=20, b=20, l=20, r=20),
                    showlegend=False,
                    font=dict(size=9),
                    yaxis=dict(tickfont=dict(size=8))
                )
                fig.update_traces(texttemplate='%{x:.1f}M', textposition='outside')
                st.plotly_chart(fig, width='stretch')
            else:
                st.info("√önico munic√≠pio na regi√£o")

def show_municipality_details_compact(df, municipality_id, selected_residues):
    """Show compact detailed analysis panel for clicked municipality"""
    
    # Convert municipality_id to appropriate type and get municipality data
    try:
        # Try as string first, then as int
        if municipality_id in df['cd_mun'].astype(str).values:
            mun_data = df[df['cd_mun'].astype(str) == str(municipality_id)].iloc[0]
        elif int(municipality_id) in df['cd_mun'].values:
            mun_data = df[df['cd_mun'] == int(municipality_id)].iloc[0]
        else:
            st.error(f"Munic√≠pio com ID {municipality_id} n√£o encontrado no dataset.")
            return
    except (ValueError, IndexError) as e:
        st.error(f"Erro ao encontrar munic√≠pio: {e}")
        return
    
    # Header with municipality info and actions
    header_col1, header_col2 = st.columns([3, 1])
    
    with header_col1:
        # Enhanced header with styling
        st.markdown(f"""
        <div style='background: linear-gradient(135deg, #2E8B57 0%, #32CD32 100%); 
                    color: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem;'>
            <h2 style='margin: 0; color: white;'>üèôÔ∏è {mun_data['nome_municipio']}</h2>
            <p style='margin: 5px 0 0 0; opacity: 0.9;'>
                üìç <strong>Regi√£o:</strong> {mun_data.get('regiao_imediata', 'N/A')} | 
                üë• <strong>Popula√ß√£o:</strong> {mun_data.get('populacao_2022', 0):,.0f} hab. | 
                üìê <strong>√Årea:</strong> {mun_data.get('area_km2', 0):.1f} km¬≤
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with header_col2:
        # Action buttons        
        if st.button("üìä Adicionar", key="add_comparison_compact", help="Adicionar √† compara√ß√£o"):
            if municipality_id not in st.session_state.selected_municipalities:
                st.session_state.selected_municipalities.append(municipality_id)
                st.toast("Munic√≠pio adicionado!", icon="‚úÖ")
                st.rerun()
    
    # Enhanced key metrics with better visualization
    st.markdown("#### üìä Indicadores Principais")
    
    # Calculate percentages for better context
    total_potential = mun_data.get('total_final_nm_ano', 0)
    agri_potential = mun_data.get('total_agricola_nm_ano', 0)
    livestock_potential = mun_data.get('total_pecuaria_nm_ano', 0)
    urban_potential = mun_data.get('total_urbano_nm_ano', 0) if 'total_urbano_nm_ano' in mun_data else 0
    
    # Calculate percentile rankings
    total_percentile = (df['total_final_nm_ano'] < total_potential).mean() * 100 if total_potential > 0 else 0
    agri_percentile = (df['total_agricola_nm_ano'] < agri_potential).mean() * 100 if agri_potential > 0 else 0
    livestock_percentile = (df['total_pecuaria_nm_ano'] < livestock_potential).mean() * 100 if livestock_potential > 0 else 0
    
    metric_cols = st.columns(4)
    
    with metric_cols[0]:
        st.metric(
            "üéØ Potencial Total", 
            f"{total_potential/1000000:.1f}M Nm¬≥/ano",
            delta=f"Top {100-total_percentile:.0f}%" if total_percentile > 50 else f"P{total_percentile:.0f}"
        )
    
    with metric_cols[1]:
        st.metric(
            "üåæ Agr√≠cola", 
            f"{agri_potential/1000000:.1f}M Nm¬≥/ano",
            delta=f"Top {100-agri_percentile:.0f}%" if agri_percentile > 50 else f"P{agri_percentile:.0f}"
        )
    
    with metric_cols[2]:
        st.metric(
            "üêÑ Pecu√°ria", 
            f"{livestock_potential/1000000:.1f}M Nm¬≥/ano",
            delta=f"Top {100-livestock_percentile:.0f}%" if livestock_percentile > 50 else f"P{livestock_percentile:.0f}"
        )
    
    with metric_cols[3]:
        st.metric(
            "üèòÔ∏è Urbano", 
            f"{urban_potential/1000000:.1f}M Nm¬≥/ano",
            delta="Estimativa" if urban_potential > 0 else "N/D"
        )
    
    # Compact tabs for detailed analysis
    compact_tabs = st.tabs(["üìã Resumo", "üèòÔ∏è Vizinhos", "üìà Ranking"])
    
    with compact_tabs[0]:  # Summary
        # Enhanced residue sources visualization
        st.markdown("**üèÜ Composi√ß√£o do Potencial de Biog√°s:**")
        
        # Create two columns: pie chart and detailed breakdown
        chart_col, detail_col = st.columns([1.5, 1])
        
        with chart_col:
            # Get the main categories data
            main_categories = {
                'üåæ Agr√≠cola': agri_potential,
                'üêÑ Pecu√°ria': livestock_potential, 
                'üèòÔ∏è Urbano': urban_potential
            }
            
            # Filter out zero values
            filtered_categories = {k: v for k, v in main_categories.items() if v > 0}
            
            if filtered_categories:
                import plotly.express as px
                import pandas as pd
                
                # Create pie chart for main categories
                pie_df = pd.DataFrame(list(filtered_categories.items()), columns=['Categoria', 'Potencial'])
                fig_pie = px.pie(pie_df, 
                               values='Potencial', 
                               names='Categoria',
                               title='Distribui√ß√£o por Categoria',
                               color_discrete_sequence=px.colors.qualitative.Set3)
                fig_pie.update_traces(textposition='inside', textinfo='percent+label')
                fig_pie.update_layout(height=300, showlegend=True)
                st.plotly_chart(fig_pie, width='stretch')
            else:
                st.info("Sem dados dispon√≠veis para visualiza√ß√£o.")
        
        with detail_col:
            st.markdown("**üìä Detalhamento por Fonte:**")
            
            # Detailed residue breakdown
            residue_data = []
            residue_icons = {
                'Biog√°s de Cana': 'üåæ', 'Biog√°s de Soja': 'üå±', 'Biog√°s de Milho': 'üåΩ',
                'Biog√°s de Caf√©': '‚òï', 'Biog√°s de Citros': 'üçä', 'Biog√°s de Bovinos': 'üêÑ',
                'Biog√°s de Su√≠nos': 'üê∑', 'Biog√°s de Aves': 'üêî', 'RSU': 'üóëÔ∏è', 'RPO': 'üõ¢Ô∏è'
            }
            
            for residue_name, column_name in RESIDUE_OPTIONS.items():
                if column_name in df.columns and 'Total' not in residue_name:
                    value = mun_data.get(column_name, 0)
                    if value > 0:
                        icon = residue_icons.get(residue_name, 'üìä')
                        residue_data.append((f"{icon} {residue_name}", value))
            
            if residue_data:
                # Sort by value and get top sources
                residue_data.sort(key=lambda x: x[1], reverse=True)
                top_residues = residue_data[:8]  # Show top 8
                
                for name, value in top_residues:
                    percentage = (value / total_potential * 100) if total_potential > 0 else 0
                    st.markdown(f"**{name}**")
                    st.markdown(f"‚îî {value/1000000:.2f}M Nm¬≥/ano ({percentage:.1f}%)")
                    st.progress(percentage/100)
                    st.markdown("")
            else:
                st.info("Nenhum dado detalhado dispon√≠vel.")
    
    with compact_tabs[1]:  # Neighbors
        st.markdown("**üèòÔ∏è Compara√ß√£o com Vizinhos (50km):**")
        try:
            neighbors = find_neighboring_municipalities(df, mun_data, radius_km=50)
            
            if len(neighbors) > 1:
                # Show top 5 neighbors - usar total_final_nm_ano como padr√£o
                neighbor_comparison = []
                current_total = mun_data.get('total_final_nm_ano', 0)
                
                for neighbor in neighbors[:6]:  # Top 5 + current
                    if neighbor['cd_mun'] != municipality_id:
                        neighbor_total = neighbor.get('total_final_nm_ano', 0)
                        neighbor_comparison.append({
                            'Munic√≠pio': neighbor['nome_municipio'],
                            'Potencial': neighbor_total,
                            'Dist√¢ncia': f"{neighbor.get('distance', 0):.1f} km"
                        })
                
                # Add current municipality for comparison
                neighbor_comparison.append({
                    'Munic√≠pio': f"{mun_data['nome_municipio']} (ATUAL)",
                    'Potencial': current_total,
                    'Dist√¢ncia': "0.0 km"
                })
                
                # Sort by potential
                neighbor_comparison.sort(key=lambda x: x['Potencial'], reverse=True)
                
                # Create a visual comparison chart
                if neighbor_comparison:
                    neighbor_df = pd.DataFrame(neighbor_comparison)
                    neighbor_df['√â_Atual'] = neighbor_df['Munic√≠pio'].str.contains('ATUAL')
                    
                    # Horizontal bar chart for neighbors
                    fig = px.bar(neighbor_df, 
                                x='Potencial', 
                                y='Munic√≠pio',
                                orientation='h',
                                title='Compara√ß√£o com Vizinhos (50km)',
                                color='√â_Atual',
                                color_discrete_map={True: '#ff6b6b', False: '#4ecdc4'},
                                labels={'Potencial': 'Potencial (Nm¬≥/ano)'})
                    fig.update_layout(height=300, showlegend=False)
                    st.plotly_chart(fig, width='stretch')
                    
                    # Show distance info in a compact table
                    st.dataframe(neighbor_df[['Munic√≠pio', 'Dist√¢ncia']].head(6), 
                                width='stretch', hide_index=True)
            else:
                st.info("Poucos vizinhos encontrados para compara√ß√£o.")
        except Exception as e:
            st.warning("N√£o foi poss√≠vel carregar dados dos vizinhos.")
    
    with compact_tabs[2]:  # Ranking
        st.markdown("**üìà Posi√ß√£o nos Rankings:**")
        
        try:
            # State ranking
            state_rank = (df['total_final_nm_ano'] >= total_potential).sum()
            state_percentile = ((len(df) - state_rank + 1) / len(df)) * 100
            
            # Regional ranking
            regional_rank = None
            regional_total = 0
            if 'regiao_imediata' in df.columns and mun_data.get('regiao_imediata'):
                regiao_imediata = mun_data.get('regiao_imediata')
                regional_df = df[df['regiao_imediata'] == regiao_imediata]
                regional_rank = (regional_df['total_final_nm_ano'] >= total_potential).sum()
                regional_total = len(regional_df)
            
            # Create ranking visualization
            ranking_data = [
                {'Categoria': 'Estado de SP', 'Posi√ß√£o': state_rank, 'Total': len(df), 'Percentil': state_percentile}
            ]
            
            if regional_rank:
                regional_percentile = ((regional_total - regional_rank + 1) / regional_total) * 100
                regiao_nome = mun_data.get('regiao_imediata', 'Regional')
                ranking_data.append({
                    'Categoria': f'Regi√£o {regiao_nome}', 
                    'Posi√ß√£o': regional_rank, 
                    'Total': regional_total,
                    'Percentil': regional_percentile
                })
            
            # Display as metrics
            rank_cols = st.columns(len(ranking_data))
            for i, rank_info in enumerate(ranking_data):
                with rank_cols[i]:
                    st.metric(
                        label=rank_info['Categoria'],
                        value=f"{rank_info['Posi√ß√£o']}¬∫ / {rank_info['Total']}",
                        delta=f"Top {rank_info['Percentil']:.0f}%"
                    )
            
            # Visual percentile representation
            fig = px.bar(
                x=[r['Categoria'] for r in ranking_data],
                y=[r['Percentil'] for r in ranking_data],
                title='Posi√ß√£o Percentual nos Rankings',
                labels={'x': 'Categoria', 'y': 'Percentil (%)'},
                color=[r['Percentil'] for r in ranking_data],
                color_continuous_scale='RdYlGn'
            )
            fig.update_layout(height=250, showlegend=False)
            st.plotly_chart(fig, width='stretch')
            
        except Exception as e:
            st.warning("N√£o foi poss√≠vel calcular rankings.")
        
        # Population category ranking
        if 'populacao_2022' in df.columns:
            population = mun_data.get('populacao_2022', 0)
            if population > 100000:
                category = "Grandes (>100k hab)"
                category_df = df[df['populacao_2022'] > 100000]
            elif population > 50000:
                category = "M√©dios (50-100k hab)"
                category_df = df[(df['populacao_2022'] > 50000) & (df['populacao_2022'] <= 100000)]
            else:
                category = "Pequenos (<50k hab)"
                category_df = df[df['populacao_2022'] <= 50000]
            
            if len(category_df) > 0:
                category_rank = (category_df['total_final_nm_ano'] >= total_potential).sum()
                st.write(f"üë• **{category}**: {category_rank}¬∫ de {len(category_df)} munic√≠pios")


def show_municipality_details(df, municipality_id, selected_residues):
    """Show detailed analysis panel for clicked municipality"""
    
    # Convert municipality_id to appropriate type and get municipality data
    try:
        # Try as string first, then as int
        if municipality_id in df['cd_mun'].astype(str).values:
            mun_data = df[df['cd_mun'].astype(str) == str(municipality_id)].iloc[0]
        elif int(municipality_id) in df['cd_mun'].values:
            mun_data = df[df['cd_mun'] == int(municipality_id)].iloc[0]
        else:
            st.error(f"Munic√≠pio com ID {municipality_id} n√£o encontrado no dataset.")
            return
    except (ValueError, IndexError) as e:
        st.error(f"Erro ao encontrar munic√≠pio: {e}")
        return
    
    # Create a prominent panel for municipality details
    st.markdown("---")
    
    # Header with municipality info
    col1, col2, col3 = st.columns([2, 1, 1])
    
    with col1:
        st.markdown(f"""
        ### üèôÔ∏è **{mun_data['nome_municipio']}**
        **Regi√£o:** {mun_data.get('regiao_imediata', 'N/A')} | 
        **Popula√ß√£o:** {mun_data.get('populacao_2022', 0):,.0f} hab. |
        **√Årea:** {mun_data.get('area_km2', 0):.1f} km¬≤
        """)
    
    with col2:
        st.empty()  # Espa√ßo vazio no lugar do bot√£o removido
    
    with col3:
        # Quick actions
        if st.button("üìä Adicionar √† Compara√ß√£o", key="add_comparison"):
            if municipality_id not in st.session_state.selected_municipalities:
                st.session_state.selected_municipalities.append(municipality_id)
                st.toast("Munic√≠pio adicionado √† compara√ß√£o!", icon="üìä")
                st.rerun()
    
    # Detailed analysis tabs
    detail_tabs = st.tabs([
        "üìã Dados Completos", 
        "üèòÔ∏è Compara√ß√£o com Vizinhos", 
        "üìà An√°lise de Potencial",
        "üó∫Ô∏è Contexto Regional"
    ])
    
    with detail_tabs[0]:  # Complete Data
        st.subheader("üìä Dados de Res√≠duos - " + mun_data['nome_municipio'])
        
        # Create comprehensive data table
        residue_data = []
        for residue_name, column_name in RESIDUE_OPTIONS.items():
            if column_name in df.columns:
                value = mun_data.get(column_name, 0)
                if value > 0:
                    # Calculate percentiles for context
                    percentile = (df[column_name] <= value).mean() * 100
                    
                    residue_data.append({
                        'Tipo de Res√≠duo': residue_name,
                        'Potencial (Nm¬≥/ano)': f"{value:,.0f}",
                        'Percentil': f"{percentile:.1f}%",
                        'Classifica√ß√£o': get_classification_label(percentile)
                    })
        
        if residue_data:
            residue_df = pd.DataFrame(residue_data)
            st.dataframe(residue_df, width='stretch')
            
            # Download button
            csv = residue_df.to_csv(index=False).encode('utf-8')
            st.download_button(
                label="üì• Baixar Dados do Munic√≠pio",
                data=csv,
                file_name=f"dados_{mun_data['nome_municipio'].replace(' ', '_')}.csv",
                mime="text/csv"
            )
        else:
            st.info("Nenhum dado de res√≠duo dispon√≠vel para este munic√≠pio.")
    
    with detail_tabs[1]:  # Neighbor Comparison
        st.subheader("üèòÔ∏è Compara√ß√£o com Munic√≠pios Vizinhos")
        
        # Find neighboring municipalities (simplified approach using lat/lng proximity)
        neighbors = find_neighboring_municipalities(df, mun_data, radius_km=50)
        
        if len(neighbors) > 1:
            # Create comparison chart
            comparison_data = []
            
            # Add current municipality
            total_current = sum([mun_data.get(col, 0) for col in selected_residues if col in df.columns])
            comparison_data.append({
                'Munic√≠pio': mun_data['nome_municipio'] + ' (SELECIONADO)',
                'Potencial Total': total_current,
                'Popula√ß√£o': mun_data.get('populacao_2022', 0),
                'Tipo': 'Selecionado'
            })
            
            # Add neighbors
            for neighbor in neighbors[:10]:  # Top 10 neighbors
                if neighbor['cd_mun'] != municipality_id:
                    neighbor_total = sum([neighbor.get(col, 0) for col in selected_residues if col in df.columns])
                    comparison_data.append({
                        'Munic√≠pio': neighbor['nome_municipio'],
                        'Potencial Total': neighbor_total,
                        'Popula√ß√£o': neighbor.get('populacao_2022', 0),
                        'Tipo': 'Vizinho'
                    })
            
            comp_df = pd.DataFrame(comparison_data)
            
            # Bar chart comparison
            fig = px.bar(
                comp_df, 
                x='Munic√≠pio', 
                y='Potencial Total',
                color='Tipo',
                color_discrete_map={'Selecionado': '#FF6B6B', 'Vizinho': '#4ECDC4'},
                title=f"Compara√ß√£o de Potencial: {mun_data['nome_municipio']} vs Vizinhos",
                height=400
            )
            fig.update_xaxis(tickangle=45)
            st.plotly_chart(fig, width='stretch')
            
            # Summary statistics
            col1, col2, col3 = st.columns(3)
            with col1:
                avg_neighbors = comp_df[comp_df['Tipo'] == 'Vizinho']['Potencial Total'].mean()
                st.metric(
                    "M√©dia dos Vizinhos", 
                    f"{avg_neighbors:,.0f} Nm¬≥/ano"
                )
            
            with col2:
                current_vs_avg = (total_current / avg_neighbors - 1) * 100 if avg_neighbors > 0 else 0
                st.metric(
                    "Diferen√ßa da M√©dia",
                    f"{current_vs_avg:+.1f}%"
                )
            
            with col3:
                rank = (comp_df['Potencial Total'] >= total_current).sum()
                st.metric(
                    "Posi√ß√£o no Ranking",
                    f"{rank}¬∫ de {len(comp_df)}"
                )
        else:
            st.info("Poucos munic√≠pios vizinhos encontrados para compara√ß√£o.")
    
    with detail_tabs[2]:  # Potential Analysis
        st.subheader("üìà An√°lise Detalhada de Potencial")
        
        # Radar chart for different residue types
        residue_values = []
        residue_names = []
        
        for residue_name, column_name in RESIDUE_OPTIONS.items():
            if column_name in df.columns:
                value = mun_data.get(column_name, 0)
                if value > 0:
                    # Normalize to 0-100 scale based on max in dataset
                    max_value = df[column_name].max()
                    normalized_value = (value / max_value) * 100 if max_value > 0 else 0
                    
                    residue_values.append(normalized_value)
                    residue_names.append(residue_name)
        
        if residue_values:
            # Create radar chart
            fig = go.Figure()
            
            fig.add_trace(go.Scatterpolar(
                r=residue_values,
                theta=residue_names,
                fill='toself',
                name=mun_data['nome_municipio'],
                line_color='#FF6B6B'
            ))
            
            fig.update_layout(
                polar=dict(
                    radialaxis=dict(
                        visible=True,
                        range=[0, 100]
                    )),
                showlegend=True,
                title=f"Perfil de Res√≠duos - {mun_data['nome_municipio']}<br><sub>Valores normalizados (0-100%)</sub>",
                height=500
            )
            
            st.plotly_chart(fig, width='stretch')
            
            # Top 3 residues
            residue_ranking = list(zip(residue_names, residue_values))
            residue_ranking.sort(key=lambda x: x[1], reverse=True)
            
            st.markdown("**üèÜ Top 3 Tipos de Res√≠duo:**")
            for i, (name, value) in enumerate(residue_ranking[:3]):
                st.write(f"{i+1}. **{name}**: {value:.1f}% do m√°ximo estadual")
    
    with detail_tabs[3]:  # Regional Context
        st.subheader("üó∫Ô∏è Contexto Regional")
        
        # Regional statistics with real data
        if 'regiao_imediata' in df.columns and mun_data.get('regiao_imediata'):
            regiao_imediata = mun_data.get('regiao_imediata', 'N/A')
            regiao_intermediaria = mun_data.get('regiao_intermediaria', 'N/A')
            
            # Filter municipalities in the same immediate region
            regional_df = df[df['regiao_imediata'] == regiao_imediata]
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown(f"**Regi√£o Imediata:** {regiao_imediata}")
                st.markdown(f"**Regi√£o Intermedi√°ria:** {regiao_intermediaria}")
                st.metric(
                    "Munic√≠pios na Regi√£o", 
                    len(regional_df)
                )
                
                # Position in region
                total_current = sum([mun_data.get(col, 0) for col in selected_residues if col in df.columns])
                regional_rank = (regional_df.apply(lambda row: sum([row.get(col, 0) for col in selected_residues if col in df.columns]), axis=1) >= total_current).sum()
                
                st.metric(
                    "Posi√ß√£o na Regi√£o",
                    f"{regional_rank}¬∫ de {len(regional_df)}"
                )
                
            with col2:
                # Regional averages
                regional_avg = regional_df.apply(lambda row: sum([row.get(col, 0) for col in selected_residues if col in df.columns]), axis=1).mean()
                state_avg = df.apply(lambda row: sum([row.get(col, 0) for col in selected_residues if col in df.columns]), axis=1).mean()
                
                st.metric(
                    "M√©dia Regional",
                    f"{regional_avg:,.0f} Nm¬≥/ano"
                )
                
                st.metric(
                    "M√©dia Estadual",
                    f"{state_avg:,.0f} Nm¬≥/ano"
                )
        else:
            st.info("üìç Dados regionais n√£o dispon√≠veis para este munic√≠pio")


def get_classification_label(percentile):
    """Get classification label based on percentile"""
    if percentile >= 90:
        return "üî• Muito Alto"
    elif percentile >= 75:
        return "üìà Alto"
    elif percentile >= 50:
        return "‚û°Ô∏è M√©dio"
    elif percentile >= 25:
        return "üìâ Baixo"
    else:
        return "‚ùÑÔ∏è Muito Baixo"


def find_neighboring_municipalities(df, target_mun, radius_km=50):
    """Find neighboring municipalities within radius"""
    target_lat = target_mun.get('lat', 0)
    target_lng = target_mun.get('lon', 0)
    
    if target_lat == 0 or target_lng == 0:
        return df.head(10).to_dict('records')  # Fallback
    
    # Calculate distances (simplified)
    distances = []
    for idx, row in df.iterrows():
        lat = row.get('lat', 0)
        lng = row.get('lon', 0)
        
        if lat != 0 and lng != 0:
            # Simplified distance calculation
            distance = ((target_lat - lat)**2 + (target_lng - lng)**2)**0.5 * 111  # Rough km conversion
            if distance <= radius_km:
                row_dict = row.to_dict()
                row_dict['distance'] = distance
                distances.append(row_dict)
    
    # Sort by distance
    distances.sort(key=lambda x: x['distance'])
    return distances


def page_main():
    """Main map page with ultra-thin sidebar and comprehensive analysis tools."""
    
    # --- 1. GERENCIAMENTO DE ESTADO ---
    if 'clicked_municipality' not in st.session_state:
        st.session_state.clicked_municipality = None
    if 'selected_municipalities' not in st.session_state:
        st.session_state.selected_municipalities = []

    # --- 2. CARREGAMENTO DE DADOS ---
    df = load_municipalities()
    if df.empty:
        st.error("‚ùå Dados n√£o encontrados.")
        return
    
    # --- IN√çCIO DA MUDAN√áA: Garantir coordenadas no DF principal ---
    # Verifica se precisa carregar coordenadas (se n√£o existem ou se todas s√£o zero)
    needs_coordinates = ('lat' not in df.columns or 'lon' not in df.columns or 
                        (df['lat'].sum() == 0 and df['lon'].sum() == 0))
    
    if needs_coordinates:
        try:
            centroid_path = Path(__file__).parent.parent.parent / "shapefile" / "municipality_centroids.parquet"
            
            if centroid_path.exists():
                centroids_df = pd.read_parquet(centroid_path)
                
                # Verifica se tem as colunas necess√°rias
                if 'lat' in centroids_df.columns and 'lon' in centroids_df.columns:
                    # Remove coordenadas antigas se existirem
                    if 'lat' in df.columns:
                        df = df.drop(['lat'], axis=1)
                    if 'lon' in df.columns:
                        df = df.drop(['lon'], axis=1)
                    
                    # Mant√©m apenas as colunas necess√°rias para o merge
                    centroids_df = centroids_df[['cd_mun', 'lat', 'lon']]
                    
                    # Faz o merge, adicionando lat/lon ao df principal
                    df = pd.merge(df, centroids_df, on='cd_mun', how='left')
                    
                    # Verifica se as colunas foram criadas e preenche valores faltantes
                    if 'lat' in df.columns and 'lon' in df.columns:
                        df['lat'] = df['lat'].fillna(0)
                        df['lon'] = df['lon'].fillna(0)
        except Exception:
            pass
    # --- FIM DA MUDAN√áA ---
    
    # --- 3. SIDEBAR DE FILTROS (ESQUERDA) ---
    with st.sidebar:
        st.markdown("""
        <div style='background: #2E8B57; color: white; padding: 0.8rem; margin: -1rem -1rem 1rem -1rem;
                    text-align: center; border-radius: 8px;'>
            <h3 style='margin: 0; font-size: 1.1rem;'>üéõÔ∏è PAINEL DE CONTROLE DO MAPA</h3>
            <p style='font-size: 0.8rem; opacity: 0.9; margin: 0.2rem 0 0 0;'>P√°gina Mapa Principal</p>
        </div>
        """, unsafe_allow_html=True)
        
        # === 1. EXPANDER PARA CAMADAS (A√ß√£o mais comum) ===
        with st.expander("üó∫Ô∏è Camadas Vis√≠veis", expanded=True):  # Come√ßa expandido
            st.write("**Dados Principais:**")
            show_municipios_biogas = st.checkbox("üìä Potencial de Biog√°s", value=False)
            
            st.write("**Infraestrutura:**")
            show_plantas_biogas = st.checkbox("üè≠ Plantas de Biog√°s", value=False)
            show_gasodutos_dist = st.checkbox("‚õΩ Distribui√ß√£o", value=False)
            show_gasodutos_transp = st.checkbox("‚õΩ Transporte", value=False)
            
            st.write("**Refer√™ncia:**")
            show_rodovias = st.checkbox("Rodovias", value=False)
            show_areas_urbanas = st.checkbox("üèòÔ∏è √Åreas Urbanas", value=False)
            show_regioes_admin = st.checkbox("üèõÔ∏è Regi√µes Admin.", value=False)
            
            # Remove rios layer completely
            show_rios = False
            
            st.write("**Imagem de Sat√©lite:**")
            show_mapbiomas = st.checkbox("üåæ MapBiomas - Uso do Solo", value=False)
            
            # Controles granulares de culturas MapBiomas ANINHADOS
            mapbiomas_classes = []
            if show_mapbiomas:
                st.markdown("<hr style='margin: 0.5rem 0;'>", unsafe_allow_html=True)  # Divisor
                with st.container(border=True):  # Borda para destacar
                    st.markdown("**Selecione as culturas a visualizar:**")
                    
                    # Organizar culturas por categoria com prioridade de cores
                    pastagem_crops = {
                        15: ('Pastagem', '#FFD966')
                    }
                    
                    temp_crops = {
                        39: ('Soja', '#E1BEE7'),
                        20: ('Cana-de-a√ß√∫car', '#C5E1A5'),
                        40: ('Arroz', '#FFCDD2'),
                        62: ('Algod√£o', '#F8BBD9'),
                        41: ('Outras Tempor√°rias', '#DCEDC8')
                    }
                    
                    perennial_crops = {
                        46: ('Caf√©', '#8D6E63'),
                        47: ('Citrus', '#FFA726'),
                        48: ('Outras Perenes', '#A1887F')
                    }
                    
                    silviculture_crops = {
                        9: ('Silvicultura', '#6D4C41')
                    }
                    
                    # Interface organizada em colunas melhorada
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.markdown("**üå± Pastagem e Silvicultura**")
                        # Pastagem
                        for code, (name, color) in pastagem_crops.items():
                            if st.checkbox(f"{name}", key=f"mapbiomas_{code}"):
                                mapbiomas_classes.append(code)
                        # Silvicultura
                        for code, (name, color) in silviculture_crops.items():
                            if st.checkbox(f"{name}", key=f"mapbiomas_{code}"):
                                mapbiomas_classes.append(code)
                    
                    with col2:
                        st.markdown("**üåæ Culturas Agr√≠colas**")
                        # Tempor√°rias
                        st.markdown("*Tempor√°rias:*")
                        for code, (name, color) in temp_crops.items():
                            if st.checkbox(f"{name}", key=f"mapbiomas_{code}"):
                                mapbiomas_classes.append(code)
                        
                        # Perenes  
                        st.markdown("*Perenes:*")
                        for code, (name, color) in perennial_crops.items():
                            if st.checkbox(f"{name}", key=f"mapbiomas_{code}"):
                                mapbiomas_classes.append(code)
                    
                    # Controles r√°pidos melhorados
                    st.markdown("<hr style='margin: 0.3rem 0;'>", unsafe_allow_html=True)
                    col_a, col_b = st.columns(2)
                    with col_a:
                        if st.button("‚úÖ Selecionar Todas", key="select_all_mapbiomas", use_container_width=True):
                            # For√ßa atualiza√ß√£o dos checkboxes
                            for code in list(pastagem_crops.keys()) + list(temp_crops.keys()) + list(perennial_crops.keys()) + list(silviculture_crops.keys()):
                                st.session_state[f"mapbiomas_{code}"] = True
                            st.toast("Todas as culturas selecionadas!", icon="‚úÖ")
                            st.rerun()
                    with col_b:
                        if st.button("‚ùå Desmarcar Todas", key="select_none_mapbiomas", use_container_width=True):
                            # For√ßa atualiza√ß√£o dos checkboxes
                            for code in list(pastagem_crops.keys()) + list(temp_crops.keys()) + list(perennial_crops.keys()) + list(silviculture_crops.keys()):
                                st.session_state[f"mapbiomas_{code}"] = False
                            st.toast("Culturas desmarcadas!", icon="‚ùå")
                            st.rerun()
        
        # === 2. EXPANDER PARA FILTROS DE DADOS ===
        with st.expander("üìä Filtros de Dados", expanded=False):
            mode = st.radio("Modo:", ["Individual", "M√∫ltiplos"], horizontal=True, key="map_mode")
            
            if mode == "Individual":
                selected = st.selectbox("Res√≠duo:", list(RESIDUE_OPTIONS.keys()), key="map_select")
                residues = [RESIDUE_OPTIONS[selected]]
                display_name = selected
            else:
                selected_list = st.multiselect("Res√≠duos:", list(RESIDUE_OPTIONS.keys()), default=["Potencial Total"], key="map_multi")
                residues = [RESIDUE_OPTIONS[item] for item in selected_list]
                display_name = f"Soma de {len(residues)} tipos" if len(residues) > 1 else (selected_list[0] if selected_list else "Nenhum")
            
            search_term = st.text_input("Buscar:", placeholder="Munic√≠pio...", key="search")
        
        # === 3. EXPANDER PARA ESTILOS DE VISUALIZA√á√ÉO ===
        with st.expander("üé® Estilos de Visualiza√ß√£o", expanded=False):
            viz_type = st.radio("Tipo de mapa:", options=["C√≠rculos Proporcionais", "Mapa de Calor (Heatmap)", "Agrupamentos (Clusters)", "Mapa de Preenchimento (Coropl√©tico)"], key="viz_type")
        
        # === 4. EXPANDER PARA AN√ÅLISE DE PROXIMIDADE ===
        with st.expander("üéØ An√°lise de Proximidade", expanded=False):
            # Initialize proximity analysis session state
            if 'catchment_center' not in st.session_state:
                st.session_state.catchment_center = None
            if 'catchment_radius' not in st.session_state:
                st.session_state.catchment_radius = 50
            
            enable_proximity = st.checkbox("Ativar An√°lise de Raio de Capta√ß√£o")
            
            if enable_proximity:
                # Substituir o slider por um radio com op√ß√µes fixas
                catchment_radius = st.radio(
                    "Selecione o Raio de Capta√ß√£o:",
                    options=[10, 30, 50],
                    format_func=lambda x: f"{x} km",
                    horizontal=True,
                    key="catchment_radius_radio"
                )
                st.session_state.catchment_radius = catchment_radius
                
                # Instru√ß√µes claras para o usu√°rio
                if st.session_state.get('catchment_center'):
                    center_lat, center_lon = st.session_state.catchment_center
                    st.success(f"Centro definido em: {center_lat:.4f}, {center_lon:.4f}")
                    if st.button("Limpar Centro", key="clear_center_proximity"):
                        st.session_state.catchment_center = None
                        st.session_state.raster_analysis_results = None  # Limpa resultados
                        st.toast("Centro de capta√ß√£o removido.", icon="üóëÔ∏è")
                        st.rerun()
                else:
                    st.info("üëÜ Clique em uma √°rea vazia do mapa para definir o centro e iniciar a an√°lise.")
            else:
                st.session_state.catchment_center = None
        
        # === 5. EXPANDER PARA OUTRAS AN√ÅLISES ===
        with st.expander("‚öôÔ∏è Outras An√°lises", expanded=False):
            st.markdown("**Classifica√ß√£o de Dados:**")
            classification = st.selectbox(
                "M√©todo:",
                options=["Linear (Intervalo Uniforme)", "Quantiles (Contagem Igual)", "Quebras Naturais (Jenks)", "Desvio Padr√£o"],
                key="classification"
            )
            
            num_classes = st.slider("N√∫mero de Classes:", min_value=3, max_value=8, value=5, key="num_classes")
            
            st.markdown("**Normaliza√ß√£o de Dados:**")
            normalization = st.selectbox(
                "M√©trica:",
                options=["Potencial Absoluto (Nm¬≥/ano)", "Potencial per Capita (Nm¬≥/hab/ano)", "Potencial por √Årea (Nm¬≥/km¬≤/ano)", "Densidade Populacional (hab/km¬≤)"],
                key="normalization"
            )
        
        # === SE√á√ÉO FIXA: MUNIC√çPIOS SELECIONADOS ===
        if st.session_state.selected_municipalities:
            st.markdown("---")
            st.markdown("**üéØ Munic√≠pios Selecionados:**")
            selected_names = df[df['cd_mun'].isin(st.session_state.selected_municipalities)]['nome_municipio'].tolist()
            for name in selected_names[:3]:
                st.markdown(f"‚Ä¢ {name[:15]}..." if len(name) > 15 else f"‚Ä¢ {name}")
            if len(selected_names) > 3:
                st.markdown(f"...+{len(selected_names)-3} mais")
            if st.button("üóëÔ∏è Limpar Sele√ß√£o", key="clear_selection"):
                st.session_state.selected_municipalities.clear()
                st.toast(f"{len(selected_names)} munic√≠pios removidos da sele√ß√£o!", icon="üóëÔ∏è")
                st.rerun()
        
        # === INSTRU√á√ÉO PARA ESCONDER SIDEBAR ===
        st.markdown("---")
        st.info("üí° Clique no √≠cone `>` no topo para recolher este painel e ampliar a visualiza√ß√£o.", icon="‚ÜîÔ∏è")

    # --- 4. APLICA√á√ÉO DOS FILTROS ---
    # Processa os dados ANTES de qualquer renderiza√ß√£o de layout
    df_to_display, display_col = apply_filters(df, {
        'residues': residues, 
        'display_name': display_name, 
        'normalization': normalization
    })

    # --- 4.5. RESUMO DOS FILTROS ATIVOS ---
    active_filters = []
    if display_name != "Potencial Total":
        active_filters.append(f"Res√≠duo: **{display_name}**")
    if search_term:
        active_filters.append(f"Busca: **'{search_term}'**")
    if normalization != "Potencial Absoluto (Nm¬≥/ano)":
        metric_short = normalization.split('(')[0].strip()
        active_filters.append(f"M√©trica: **{metric_short}**")
    if show_mapbiomas and mapbiomas_classes:
        active_filters.append(f"MapBiomas: **{len(mapbiomas_classes)} culturas**")
    
    if active_filters:
        st.info(f"üéØ Filtros Ativos: {' | '.join(active_filters)}")

    # --- 5. LAYOUT HORIZONTAL: MAPA E DETALHES LADO A LADO ---
    if st.session_state.clicked_municipality:
        # Layout horizontal: mapa (60%) e detalhes (40%)
        map_col, details_col = st.columns([0.6, 0.4])
        
        with details_col:
            # Container para detalhes com altura fixa e scroll
            with st.container():
                try:
                    mun_data = df[df['cd_mun'].astype(str) == str(st.session_state.clicked_municipality)].iloc[0]
                    mun_name = mun_data['nome_municipio']

                    # Cabe√ßalho compacto do painel
                    if st.button("üîô Voltar ao Mapa", key="close_details_button", help="Voltar ao mapa principal", width='stretch'):
                        st.session_state.clicked_municipality = None
                        st.rerun()
                    
                    st.markdown(f"### üîç {mun_name}")
                    st.markdown("---")

                    # Detalhes em container com altura controlada
                    with st.container():
                        # Vers√£o compacta da fun√ß√£o de detalhes
                        show_municipality_details_horizontal(df, st.session_state.clicked_municipality, residues)

                except Exception as e:
                    st.error(f"Erro ao carregar detalhes: {str(e)}")
                    if st.button("üîÑ Tentar Novamente", key="retry_details"):
                        st.rerun()
        
        with map_col:
            # --- RENDERIZA√á√ÉO DO MAPA ---
            # Crie um dicion√°rio com as informa√ß√µes da an√°lise
            catchment_info = None
            if enable_proximity and st.session_state.get('catchment_center'):
                catchment_info = {
                    "center": st.session_state.catchment_center,
                    "radius": st.session_state.catchment_radius
                }
            
            
            map_object, legend_html = create_centroid_map_optimized(df_to_display, display_col, search_term=search_term, viz_type=viz_type, show_mapbiomas_layer=show_mapbiomas, mapbiomas_classes=mapbiomas_classes, show_rios=show_rios, show_rodovias=show_rodovias, show_plantas_biogas=show_plantas_biogas, show_gasodutos_dist=show_gasodutos_dist, show_gasodutos_transp=show_gasodutos_transp, show_areas_urbanas=show_areas_urbanas, show_regioes_admin=show_regioes_admin, show_municipios_biogas=show_municipios_biogas, catchment_info=catchment_info)
            
            # Exibir legenda na sidebar se existir
            if legend_html and show_municipios_biogas:
                with st.sidebar:
                    st.markdown("---")
                    st.markdown(legend_html, unsafe_allow_html=True)
            
            map_data = st_folium(map_object, key="main_map", width=None, height=700)  # Altura maior para compensar layout horizontal
    else:
        # Mapa em largura total quando n√£o h√° detalhes
        # Crie um dicion√°rio com as informa√ß√µes da an√°lise
        catchment_info = None
        if enable_proximity and st.session_state.get('catchment_center'):
            catchment_info = {
                "center": st.session_state.catchment_center,
                "radius": st.session_state.catchment_radius
            }
        
        
        map_object, legend_html = create_centroid_map_optimized(df_to_display, display_col, search_term=search_term, viz_type=viz_type, show_mapbiomas_layer=show_mapbiomas, mapbiomas_classes=mapbiomas_classes, show_rios=show_rios, show_rodovias=show_rodovias, show_plantas_biogas=show_plantas_biogas, show_gasodutos_dist=show_gasodutos_dist, show_gasodutos_transp=show_gasodutos_transp, show_areas_urbanas=show_areas_urbanas, show_regioes_admin=show_regioes_admin, show_municipios_biogas=show_municipios_biogas, catchment_info=catchment_info)
        
        # Exibir legenda na sidebar se existir
        if legend_html and show_municipios_biogas:
            with st.sidebar:
                st.markdown("---")
                st.markdown(legend_html, unsafe_allow_html=True)
        
        map_data = st_folium(map_object, key="main_map", width=None, height=600)
    
    # === CONTAINER PARA RESULTADOS DA AN√ÅLISE DE PROXIMIDADE ===
    if enable_proximity and st.session_state.get('catchment_center'):
        
        # --- Executa as an√°lises ---
        with st.spinner("üîç Analisando √°rea... Calculando uso do solo e potencial de biog√°s..."):
            
            center_lat, center_lon = st.session_state.catchment_center
            radius_km = st.session_state.catchment_radius
            
            # An√°lise RASTER (Uso do Solo)
            if st.session_state.get('raster_analysis_results') is None:
                # Verifica√ß√£o se o sistema de raster est√° dispon√≠vel
                if not HAS_RASTER_SYSTEM or analyze_raster_in_radius is None:
                    st.error("üîß Sistema de an√°lise de raster n√£o est√° dispon√≠vel. Verifique a instala√ß√£o das depend√™ncias.")
                    st.session_state.raster_analysis_results = {}
                else:
                    try:
                        # Encontra o caminho do raster dinamicamente
                        project_root = Path(__file__).parent.parent.parent
                        raster_dir = project_root / "rasters"
                        
                        # Procura por arquivos .tif ou .tiff
                        raster_files = list(raster_dir.glob("*.tif")) + list(raster_dir.glob("*.tiff"))
                        
                        if not raster_files:
                            st.error(f"üìÇ Nenhum arquivo raster (.tif) encontrado na pasta '{raster_dir}'.")
                            st.session_state.raster_analysis_results = {}
                        else:
                            raster_path = str(raster_files[0])  # Usa o primeiro que encontrar
                            st.info(f"üîç Analisando raster: {Path(raster_path).name}")

                            # Mapa de classes que a fun√ß√£o de an√°lise precisa
                            class_map = {
                                15: 'Pastagem', 39: 'Soja', 20: 'Cana-de-a√ß√∫car', 40: 'Arroz',
                                62: 'Algod√£o', 41: 'Outras Tempor√°rias', 46: 'Caf√©', 47: 'Citrus',
                                48: 'Outras Perenes', 9: 'Silvicultura'
                            }
                            
                            # *** ESTA √â A CHAMADA REAL ***
                            real_results = analyze_raster_in_radius(
                                raster_path=raster_path,
                                center_lat=center_lat,
                                center_lon=center_lon,
                                radius_km=radius_km,
                                class_map=class_map
                            )
                            
                            st.session_state.raster_analysis_results = real_results
                            st.success(f"‚úÖ An√°lise conclu√≠da: {len(real_results)} tipos de cultura encontrados")

                    except Exception as e:
                        st.error(f"‚ùå Falha na an√°lise real do raster: {e}")
                        import traceback
                        with st.expander("üîç Detalhes do erro"):
                            st.code(traceback.format_exc())
                        st.session_state.raster_analysis_results = None

        # --- Exibe os resultados da an√°lise raster ---
        if st.session_state.get('raster_analysis_results'):
            results = st.session_state.raster_analysis_results
            st.markdown("---")
            st.markdown(f"### üéØ An√°lise de Uso do Solo no Raio de {st.session_state.catchment_radius} km")
            
            if results:
                import pandas as pd  # Local import to ensure availability
                
                df_results = pd.DataFrame(list(results.items()), columns=['Cultura', '√Årea (Hectares)'])
                df_results = df_results[df_results['√Årea (Hectares)'] > 0].sort_values(by='√Årea (Hectares)', ascending=False)
                
                if not df_results.empty:
                    col1, col2 = st.columns([1, 1.5])
                    with col1:
                        # Gr√°fico de pizza
                        fig = px.pie(df_results, names='Cultura', values='√Årea (Hectares)', 
                                   title='ü•ß Composi√ß√£o da √Årea por Cultura')
                        st.plotly_chart(fig, use_container_width=True)
                        
                        # M√©tricas resumo
                        total_area = df_results['√Årea (Hectares)'].sum()
                        st.metric("üìä √Årea Total Analisada", f"{total_area:,.1f} ha")
                        
                        # Potencial estimado baseado na √°rea (exemplo)
                        estimated_potential = total_area * 45  # 45 Nm¬≥/ha/ano (m√©dia estimada)
                        st.metric("‚ö° Potencial Estimado de Biog√°s", f"{estimated_potential:,.0f} Nm¬≥/ano")
                        
                    with col2:
                        # Tabela detalhada
                        st.markdown("#### üìã Detalhamento por Cultura")
                        
                        # Adiciona coluna de percentual
                        df_results['Percentual (%)'] = (df_results['√Årea (Hectares)'] / df_results['√Årea (Hectares)'].sum() * 100).round(1)
                        
                        # Adiciona estimativa de potencial por cultura
                        potencial_por_cultura = {
                            'Pastagem': 35,
                            'Soja': 25, 
                            'Cana-de-a√ß√∫car': 85,
                            'Caf√©': 30,
                            'Citrus': 40,
                            'Milho': 45
                        }
                        
                        df_results['Potencial Estimado (Nm¬≥/ano)'] = df_results.apply(
                            lambda row: int(row['√Årea (Hectares)'] * potencial_por_cultura.get(row['Cultura'], 40)), 
                            axis=1
                        )
                        
                        st.dataframe(df_results, 
                                   column_config={
                                       "Cultura": "üåæ Cultura",
                                       "√Årea (Hectares)": st.column_config.NumberColumn("üìè √Årea (ha)", format="%.1f"),
                                       "Percentual (%)": st.column_config.NumberColumn("üìä %", format="%.1f"),
                                       "Potencial Estimado (Nm¬≥/ano)": st.column_config.NumberColumn("‚ö° Potencial (Nm¬≥/ano)", format="%d")
                                   },
                                   use_container_width=True, hide_index=True)
                        
                        # Resumo das principais culturas
                        st.markdown("##### üéØ Principais Oportunidades:")
                        top_3 = df_results.head(3)
                        for _, row in top_3.iterrows():
                            st.markdown(f"‚Ä¢ **{row['Cultura']}**: {row['√Årea (Hectares)']:.1f} ha ({row['Percentual (%)']:.1f}%)")
                            
                else:
                    st.info("üîç Nenhuma cultura agropecu√°ria foi identificada na √°rea selecionada.")
            else:
                st.warning("‚ö†Ô∏è A an√°lise n√£o retornou resultados. A √°rea pode estar fora da cobertura dos dados MapBiomas.")

    # --- 7. PROCESSAMENTO DE CLIQUE DO MAPA (NOVA ABORDAGEM) ---
    clicked_id = None
    
    if map_data and map_data.get("last_object_clicked"):
        # Pega as coordenadas do clique
        click_lat = map_data["last_object_clicked"]['lat']
        click_lon = map_data["last_object_clicked"]['lng']
        
        # Encontra o munic√≠pio mais pr√≥ximo dessas coordenadas
        if 'lat' in df.columns and 'lon' in df.columns:
            valid_coords = df[(df['lat'] != 0) & (df['lon'] != 0)].copy()
            
            if len(valid_coords) > 0:
                distances = np.sqrt((valid_coords['lat'] - click_lat)**2 + (valid_coords['lon'] - click_lon)**2)
                closest_idx = distances.idxmin()
                closest_mun = valid_coords.loc[closest_idx]
                
                clicked_id = closest_mun['cd_mun']
                
                # Atualiza o estado da sess√£o
                if st.session_state.clicked_municipality != clicked_id:
                    st.session_state.clicked_municipality = clicked_id
                    st.rerun()

    # An√°lise de proximidade para cliques em √°rea vazia
    if enable_proximity and map_data and map_data.get("last_clicked"):
        # Apenas aciona se o clique N√ÉO foi em um objeto existente
        if not map_data.get("last_object_clicked"):
            
            new_center = (
                map_data["last_clicked"]["lat"],
                map_data["last_clicked"]["lng"]
            )
            
            # Pega o centro atual, se existir
            current_center = st.session_state.get('catchment_center')
            
            # COMPARA o novo clique com o anterior para evitar rec√°lculos desnecess√°rios
            # A toler√¢ncia pequena previne problemas com cliques m√∫ltiplos no mesmo lugar
            if current_center is None or \
               abs(new_center[0] - current_center[0]) > 0.0001 or \
               abs(new_center[1] - current_center[1]) > 0.0001:
                
                # √â um novo local de an√°lise!
                st.toast("üéØ Novo centro de an√°lise definido!", icon="üéØ")
                
                # **A CORRE√á√ÉO DO BUG EST√Å AQUI:**
                # Limpa os resultados antigos para for√ßar o rec√°lculo
                st.session_state.raster_analysis_results = None
                st.session_state.vector_analysis_results = None
                
                # Define o novo centro
                st.session_state.catchment_center = new_center
                
                # For√ßa o recarregamento da p√°gina para atualizar o mapa e iniciar a an√°lise
                st.rerun()

    # --- 8. FERRAMENTAS DE AN√ÅLISE (SEMPRE VIS√çVEIS ABAIXO) ---
    st.markdown("---")
    st.markdown("## üìä Ferramentas de An√°lise Avan√ßada")
    analysis_tabs = st.tabs([
        "üìà An√°lise Geral", "üîç An√°lise Detalhada", "‚öñÔ∏è Compara√ß√£o", 
        "üéØ Filtros Avan√ßados", "üìã Dados Completos"
    ])
    
    with analysis_tabs[0]:
        # L√≥gica corrigida para exibir a an√°lise correta
        if st.session_state.selected_municipalities:
            selected_df = df[df['cd_mun'].isin(st.session_state.selected_municipalities)]
            st.markdown(f"### üî¨ An√°lise para **{len(selected_df)}** Munic√≠pio(s) Selecionado(s)")
            
            if len(selected_df) == 1:
                mun = selected_df.iloc[0]
                st.markdown(f"#### Perfil Completo: **{mun['nome_municipio']}**")
                
                # Key metrics for single municipality
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Popula√ß√£o", f"{mun.get('populacao_2022', 'N/A'):,}" if pd.notna(mun.get('populacao_2022')) else "N/A")
                with col2:
                    st.metric("Potencial Total", f"{mun['total_final_nm_ano']:,.0f}")
                with col3:
                    st.metric("Agr√≠cola", f"{mun['total_agricola_nm_ano']:,.0f}")
                with col4:
                    st.metric("Pecu√°ria", f"{mun['total_pecuaria_nm_ano']:,.0f}")
                
                # Donut chart for composition
                residue_cols = {v: k for k, v in RESIDUE_OPTIONS.items() if 'Total' not in k}
                analysis_df = selected_df[['nome_municipio'] + list(residue_cols.keys())]
                melted_df = analysis_df.melt(id_vars='nome_municipio', var_name='Tipo', value_name='Potencial').rename(columns={'nome_municipio': 'Munic√≠pio'})
                melted_df['Tipo'] = melted_df['Tipo'].map(residue_cols)
                melted_df = melted_df[melted_df['Potencial'] > 0]  # Remove zeros for cleaner chart
                
                if not melted_df.empty:
                    fig = px.pie(melted_df, names='Tipo', values='Potencial', 
                               title='Composi√ß√£o do Potencial por Tipo de Res√≠duo', hole=0.4)
                    st.plotly_chart(fig, width='stretch')
                
            else: # M√∫ltiplos munic√≠pios
                st.markdown("#### Comparativo entre Munic√≠pios Selecionados")
                
                # Enhanced summary metrics
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Total Selecionados", len(selected_df))
                with col2:
                    total_potential = selected_df['total_final_nm_ano'].sum()
                    st.metric("Potencial Conjunto", f"{total_potential:,.0f} Nm¬≥/ano")
                with col3:
                    avg_potential = selected_df['total_final_nm_ano'].mean()
                    st.metric("M√©dia por Munic√≠pio", f"{avg_potential:,.0f} Nm¬≥/ano")
                with col4:
                    if 'populacao_2022' in selected_df.columns:
                        total_population = selected_df['populacao_2022'].sum()
                        if total_population > 0:
                            potential_per_capita = total_potential / total_population
                            st.metric("Potencial per Capita", f"{potential_per_capita:.1f} Nm¬≥/hab/ano")
                
                # Main comparison chart
                fig_bar = px.bar(
                    selected_df, 
                    x='nome_municipio', 
                    y='total_final_nm_ano',
                    title='Potencial Total por Munic√≠pio',
                    color='total_final_nm_ano',
                    color_continuous_scale='Viridis'
                )
                fig_bar.update_layout(height=400, xaxis_tickangle=45)
                st.plotly_chart(fig_bar, width='stretch')
        else:
            # An√°lise estadual padr√£o (quando NENHUM munic√≠pio est√° selecionado)
            st.markdown("### üìä An√°lise Estadual: " + display_name)
            
            col1, col2 = st.columns(2)
            with col1:
                st.markdown("##### üèÜ Top 15 Munic√≠pios")
                chart1 = create_top_chart(df_to_display, display_col, display_name, limit=15)
                if chart1: 
                    st.plotly_chart(chart1, width='stretch')
            
            with col2:
                st.markdown("##### üìà Distribui√ß√£o")
                chart2 = create_distribution_chart(df_to_display, display_col, display_name)
                if chart2: 
                    st.plotly_chart(chart2, width='stretch')
            
            # Estat√≠sticas resumidas
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("üìä M√©dia", f"{df_to_display[display_col].mean():,.0f}")
            with col2:
                st.metric("üìä Mediana", f"{df_to_display[display_col].median():,.0f}")
            with col3:
                st.metric("üìä Desvio Padr√£o", f"{df_to_display[display_col].std():,.0f}")
            with col4:
                st.metric("üìä Soma Total", f"{df_to_display[display_col].sum():,.0f}")

    with analysis_tabs[1]:  # Detailed Analysis
        st.markdown("### üîç An√°lise Detalhada por Categoria")
        
        # Category comparison
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("#### üåæ Res√≠duos Agr√≠colas")
            agri_data = []
            agri_types = ['Cana-de-a√ß√∫car', 'Soja', 'Milho', 'Caf√©', 'Citros']
            for res_type in agri_types:
                col_name = RESIDUE_OPTIONS[res_type]
                top_mun = df.nlargest(1, col_name).iloc[0] if not df[col_name].isna().all() else None
                if top_mun is not None:
                    agri_data.append({
                        'Tipo': res_type,
                        'L√≠der': top_mun['nome_municipio'],
                        'Potencial': top_mun[col_name]
                    })
            
            if agri_data:
                import pandas as pd  # Import local para garantir disponibilidade
                agri_df = pd.DataFrame(agri_data)
                fig = px.bar(agri_df, x='Tipo', y='Potencial', 
                           title='L√≠deres por Categoria Agr√≠cola')
                fig.update_layout(xaxis_tickangle=-45)
                st.plotly_chart(fig, width='stretch')
                
                st.dataframe(agri_df, width='stretch')
        
        with col2:
            st.markdown("#### üêÑ Res√≠duos Pecu√°rios")
            pec_data = []
            pec_types = ['Bovinos', 'Su√≠nos', 'Aves', 'Piscicultura']
            for res_type in pec_types:
                col_name = RESIDUE_OPTIONS[res_type]
                top_mun = df.nlargest(1, col_name).iloc[0] if not df[col_name].isna().all() else None
                if top_mun is not None:
                    pec_data.append({
                        'Tipo': res_type,
                        'L√≠der': top_mun['nome_municipio'],
                        'Potencial': top_mun[col_name]
                    })
            
            if pec_data:
                import pandas as pd  # Import local para garantir disponibilidade
                pec_df = pd.DataFrame(pec_data)
                fig = px.bar(pec_df, x='Tipo', y='Potencial',
                           title='L√≠deres por Categoria Pecu√°ria')
                fig.update_layout(xaxis_tickangle=-45)
                st.plotly_chart(fig, width='stretch')
                
                st.dataframe(pec_df, width='stretch')
    
    with analysis_tabs[2]:  # Comparison Tools
        st.markdown("### ‚öñÔ∏è Ferramentas de Compara√ß√£o")
        
        # Municipality selector for comparison
        st.markdown("#### Selecionar Munic√≠pios para Compara√ß√£o")
        municipalities_list = df['nome_municipio'].tolist()
        selected_for_comparison = st.multiselect(
            "Escolha at√© 5 munic√≠pios para comparar:",
            municipalities_list,
            max_selections=5,
            key="comparison_select"
        )
        
        if selected_for_comparison:
            comparison_df = df[df['nome_municipio'].isin(selected_for_comparison)]
            
            # Summary table
            summary_cols = ['nome_municipio', 'total_final_nm_ano', 'total_agricola_nm_ano', 'total_pecuaria_nm_ano']
            available_summary_cols = [col for col in summary_cols if col in comparison_df.columns]
            summary_df = comparison_df[available_summary_cols].round(0)
            st.dataframe(summary_df, width='stretch')
    
    with analysis_tabs[3]:  # Advanced Filters
        st.markdown("### üéØ Filtros Avan√ßados e Sele√ß√£o Inteligente")
        
        # Quick selection presets
        st.markdown("#### ‚ö° Sele√ß√µes R√°pidas")
        preset_col1, preset_col2, preset_col3, preset_col4 = st.columns(4)
        
        with preset_col1:
            if st.button("üèÜ Top 10 Potencial", key="top_10"):
                top_municipalities = df.nlargest(10, display_col)['cd_mun'].tolist()
                st.session_state.selected_municipalities = top_municipalities
                st.toast("Top 10 munic√≠pios selecionados!", icon="üèÜ")
                st.rerun()
        
        with preset_col2:
            if st.button("üåæ Foco Agr√≠cola", key="agri_focus"):
                agri_municipalities = df[df['total_agricola_nm_ano'] > df['total_agricola_nm_ano'].quantile(0.75)]['cd_mun'].tolist()
                st.session_state.selected_municipalities = agri_municipalities
                st.toast(f"{len(agri_municipalities)} munic√≠pios agr√≠colas selecionados!", icon="üåæ")
                st.rerun()
        
        with preset_col3:
            if st.button("üêÑ Foco Pecu√°rio", key="livestock_focus"):
                livestock_municipalities = df[df['total_pecuaria_nm_ano'] > df['total_pecuaria_nm_ano'].quantile(0.75)]['cd_mun'].tolist()
                st.session_state.selected_municipalities = livestock_municipalities
                st.toast(f"{len(livestock_municipalities)} munic√≠pios pecu√°rios selecionados!", icon="üêÑ")
                st.rerun()
        
        with preset_col4:
            if st.button("üîÑ Limpar Sele√ß√£o", key="clear_all"):
                num_selected = len(st.session_state.selected_municipalities)
                st.session_state.selected_municipalities = []
                st.toast(f"Sele√ß√£o limpa! {num_selected} munic√≠pios removidos.", icon="üîÑ")
                st.rerun()
        
        # Show filtered results
        if st.session_state.selected_municipalities:
            filtered_df = df[df['cd_mun'].isin(st.session_state.selected_municipalities)]
            st.markdown(f"**Resultado:** {len(filtered_df)} munic√≠pios selecionados")
            
            chart = create_top_chart(filtered_df, display_col, "Munic√≠pios Selecionados", limit=10)
            if chart:
                st.plotly_chart(chart, width='stretch')
    
    with analysis_tabs[4]:  # Complete Data
        st.markdown("### üìã Dados Completos")
        
        # Data download options
        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("üì• Download CSV Completo"):
                csv = df.to_csv(index=False)
                st.download_button("üíæ Baixar", csv, "cp2b_completo.csv", "text/csv")
        
        with col2:
            if st.button("üì• Download Selecionados"):
                if st.session_state.selected_municipalities:
                    selected_df = df[df['cd_mun'].isin(st.session_state.selected_municipalities)]
                    csv = selected_df.to_csv(index=False)
                    st.download_button("üíæ Baixar", csv, "cp2b_selecionados.csv", "text/csv")
                else:
                    st.warning("Nenhum munic√≠pio selecionado")
        
        with col3:
            if st.button("üì• Download por Filtro"):
                csv = df_to_display.to_csv(index=False)
                st.download_button("üíæ Baixar", csv, f"cp2b_{display_name.lower()}.csv", "text/csv")
        
        # Full data table with search and sorting
        st.markdown("#### Tabela Completa de Dados")
        search_table = st.text_input("üîç Buscar na tabela:", key="table_search")
        
        display_df = df.copy()
        if search_table:
            display_df = display_df[display_df['nome_municipio'].str.contains(search_table, case=False, na=False)]
        
        # Column selector
        all_numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
        selected_cols = st.multiselect(
            "Selecionar colunas para exibir:",
            ['nome_municipio'] + all_numeric_cols,
            default=['nome_municipio', 'total_final_nm_ano', 'total_agricola_nm_ano', 'total_pecuaria_nm_ano'],
            key="column_selector"
        )
        
        if selected_cols:
            available_selected_cols = [col for col in selected_cols if col in display_df.columns]
            final_display_df = display_df[available_selected_cols].sort_values(by=available_selected_cols[1] if len(available_selected_cols) > 1 else available_selected_cols[0], ascending=False)
            st.dataframe(final_display_df, width='stretch', height=600)

def page_explorer():
    """User-Friendly Data Explorer - Designed for Non-Technical Users"""
    
    # Welcome header with clear instructions
    st.markdown("""
    <div style='background: linear-gradient(135deg, #4CAF50 0%, #2E8B57 100%); 
                color: white; padding: 2rem; margin: -1rem -1rem 2rem -1rem;
                text-align: center; border-radius: 0 0 20px 20px;'>
        <h1 style='margin: 0; font-size: 2.5rem;'>üîç Explorar Dados de Biog√°s</h1>
        <p style='margin: 10px 0 0 0; font-size: 1.2rem; opacity: 0.9;'>
            Descubra o potencial de biog√°s nos munic√≠pios de S√£o Paulo de forma simples!
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    df = load_municipalities()
    
    if df.empty:
        st.error("‚ùå Dados n√£o encontrados.")
        return
    
    # Step-by-step guided exploration
    st.markdown("### üéØ Passo 1: Escolha o que voc√™ quer analisar")
    
    # Simple, clear selection with explanations
    col1, col2 = st.columns([3, 1])
    
    with col1:
        st.markdown("""
        **Selecione o tipo de res√≠duo que voc√™ quer explorar:**
        - üåæ **Res√≠duos Agr√≠colas**: Cana-de-a√ß√∫car, soja, milho, caf√©, citros
        - üêÑ **Res√≠duos Pecu√°rios**: Bovinos, su√≠nos, aves, piscicultura  
        - üèôÔ∏è **Res√≠duos Urbanos**: Lixo urbano e res√≠duos de poda
        - üìä **Totais**: Somas por categoria ou geral
        """)
        
        # Simple selection
        selected_type = st.selectbox(
            "Escolha o tipo de res√≠duo:",
            options=list(RESIDUE_OPTIONS.keys()),
            index=0,
            key="explorer_residue_type",
            help="Cada tipo representa uma fonte diferente de biog√°s"
        )
        
        display_col = RESIDUE_OPTIONS[selected_type]
    
    with col2:
        st.info("""
        üí° **Dica:**
        
        Comece com "Potencial Total" para ter uma vis√£o geral, depois explore tipos espec√≠ficos!
        """)
    
    # Filter data
    df_filtered = df[df[display_col] > 0].copy()  # Only show municipalities with data
    
    if df_filtered.empty:
        st.warning("‚ö†Ô∏è Nenhum munic√≠pio tem dados para este tipo de res√≠duo.")
        return
    
    # Step 2: Overview with clear explanations
    st.markdown("---")
    st.markdown(f"### üìä Passo 2: Vis√£o Geral - {selected_type}")
    
    # Simple, clear metrics
    col1, col2, col3, col4 = st.columns(4)
    
    total_municipalities = len(df_filtered)
    total_potential = df_filtered[display_col].sum()
    average_potential = df_filtered[display_col].mean()
    top_municipality = df_filtered.loc[df_filtered[display_col].idxmax(), 'nome_municipio']
    
    with col1:
        st.metric(
            "üèòÔ∏è Munic√≠pios com Potencial", 
            f"{total_municipalities:,}",
            help="Quantidade de munic√≠pios que t√™m este tipo de res√≠duo"
        )
    
    with col2:
        st.metric(
            "üî• Potencial Total", 
            f"{total_potential/1_000_000:.1f}M Nm¬≥/ano",
            help="Soma de todo o potencial de biog√°s deste tipo em SP"
        )
    
    with col3:
        st.metric(
            "üìä Potencial M√©dio", 
            f"{average_potential/1_000:.0f}K Nm¬≥/ano",
            help="M√©dia do potencial por munic√≠pio"
        )
    
    with col4:
        st.metric(
            "üèÜ Munic√≠pio L√≠der", 
            top_municipality,
            help="Munic√≠pio com maior potencial neste tipo"
        )
    
    # Step 3: Visual exploration with explanations
    st.markdown("---")
    st.markdown("### üìà Passo 3: Veja os Dados de Forma Visual")
    
    # Simplified tabs with clear explanations
    viz_tabs = st.tabs([
        "üèÜ Ranking dos Melhores", 
        "üìä Como os Valores se Distribuem", 
        "üîç Compare Munic√≠pios"
    ])
    
    with viz_tabs[0]:  # Ranking - Most intuitive for users
        st.markdown("#### ü•á Os Munic√≠pios com Maior Potencial")
        st.markdown(f"*Veja quais munic√≠pios lideram na produ√ß√£o de biog√°s a partir de {selected_type.lower()}*")
        
        # User-friendly top N selector
        top_n = st.selectbox(
            "Quantos munic√≠pios voc√™ quer ver no ranking?",
            options=[5, 10, 15, 20, 30],
            index=1,  # Default to 10
            key="ranking_top_n"
        )
        
        top_municipalities = df_filtered.nlargest(top_n, display_col)
        
        # Create ranking table with position
        ranking_data = []
        for i, (_, row) in enumerate(top_municipalities.iterrows(), 1):
            ranking_data.append({
                "üèÖ Posi√ß√£o": f"{i}¬∫",
                "üèòÔ∏è Munic√≠pio": row['nome_municipio'],
                "üî• Potencial (Nm¬≥/ano)": format_number(row[display_col])
            })
        
        ranking_df = pd.DataFrame(ranking_data)
        st.dataframe(ranking_df, width='stretch', hide_index=True)
        
        # Visual ranking chart
        fig_ranking = px.bar(
            top_municipalities.head(10),  # Show top 10 in chart
            x=display_col,
            y='nome_municipio',
            orientation='h',
            title=f"üèÜ Top 10 Munic√≠pios - {selected_type}",
            labels={display_col: "Potencial de Biog√°s (Nm¬≥/ano)", 'nome_municipio': 'Munic√≠pio'},
            color=display_col,
            color_continuous_scale='Greens'
        )
        fig_ranking.update_layout(
            height=500,
            showlegend=False,
            yaxis={'categoryorder': 'total ascending'}
        )
        st.plotly_chart(fig_ranking, width='stretch')
        
        # Simple insights
        if top_n >= 3:
            top_3_sum = top_municipalities.head(3)[display_col].sum()
            percentage = (top_3_sum / total_potential) * 100
            st.info(f"üí° **Insight:** Os 3 munic√≠pios l√≠deres concentram {percentage:.1f}% de todo o potencial!")
    
    with viz_tabs[1]:  # Distribution - Simplified
        st.markdown("#### üìä Como os Valores Est√£o Distribu√≠dos")
        st.markdown("*Entenda se a maioria dos munic√≠pios tem valores altos, baixos ou medianos*")
        
        # Simple histogram with explanation
        fig_hist = px.histogram(
            df_filtered, 
            x=display_col,
            nbins=20,  # Fixed, simpler number
            title=f"Distribui√ß√£o do Potencial - {selected_type}",
            labels={display_col: "Potencial de Biog√°s (Nm¬≥/ano)", 'count': 'Quantidade de Munic√≠pios'},
            color_discrete_sequence=['#2E8B57']
        )
        fig_hist.update_layout(height=400)
        st.plotly_chart(fig_hist, width='stretch')
        
        # Simple explanation of what this means
        median_val = df_filtered[display_col].median()
        above_median = len(df_filtered[df_filtered[display_col] > median_val])
        below_median = len(df_filtered[df_filtered[display_col] <= median_val])
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("üìà Munic√≠pios Acima da Mediana", above_median)
        with col2:
            st.metric("üìâ Munic√≠pios Abaixo da Mediana", below_median)
        
        st.markdown(f"""
        **üìñ O que isso significa:**
        - A mediana √© {format_number(median_val)} Nm¬≥/ano
        - {above_median} munic√≠pios t√™m potencial acima deste valor
        - {below_median} munic√≠pios t√™m potencial abaixo deste valor
        """)
    
    with viz_tabs[2]:  # Comparison - User selects municipalities
        st.markdown("#### üîç Compare Munic√≠pios de Seu Interesse")
        st.markdown("*Escolha munic√≠pios espec√≠ficos para comparar lado a lado*")
        
        # Municipality search and selection
        st.markdown("**Busque e selecione munic√≠pios:**")
        search_mun = st.text_input(
            "Digite o nome de um munic√≠pio para buscar:",
            placeholder="Ex: S√£o Paulo, Campinas, Santos...",
            key="municipality_search"
        )
        
        # Filter municipalities based on search
        available_municipalities = df_filtered['nome_municipio'].tolist()
        if search_mun:
            available_municipalities = [
                m for m in available_municipalities 
                if search_mun.lower() in m.lower()
            ]
        
        selected_municipalities = st.multiselect(
            "Escolha at√© 5 munic√≠pios para comparar:",
            options=available_municipalities,
            default=df_filtered.nlargest(3, display_col)['nome_municipio'].tolist()[:3],
            max_selections=5,
            key="municipality_comparison_simple"
        )
        
        if selected_municipalities:
            # Create comparison data
            comparison_data = []
            for municipality in selected_municipalities:
                mun_data = df_filtered[df_filtered['nome_municipio'] == municipality].iloc[0]
                comparison_data.append({
                    'üèòÔ∏è Munic√≠pio': municipality,
                    f'üî• {selected_type}': format_number(mun_data[display_col])
                })
            
            comparison_df = pd.DataFrame(comparison_data)
            st.dataframe(comparison_df, width='stretch', hide_index=True)
            
            # Visual comparison
            if len(selected_municipalities) > 1:
                comparison_values = []
                for municipality in selected_municipalities:
                    mun_data = df_filtered[df_filtered['nome_municipio'] == municipality].iloc[0]
                    comparison_values.append({
                        'Munic√≠pio': municipality,
                        'Potencial': mun_data[display_col]
                    })
                
                comp_df = pd.DataFrame(comparison_values)
                fig_comparison = px.bar(
                    comp_df,
                    x='Munic√≠pio',
                    y='Potencial',
                    title=f"Compara√ß√£o - {selected_type}",
                    labels={'Potencial': 'Potencial (Nm¬≥/ano)'},
                    color='Potencial',
                    color_continuous_scale='Greens'
                )
                fig_comparison.update_layout(height=400)
                st.plotly_chart(fig_comparison, width='stretch')
    
    # Step 4: Explore all data
    st.markdown("---")
    st.markdown("### üìã Passo 4: Explore Todos os Dados")
    
    # Simple search and filter
    col1, col2 = st.columns([2, 1])
    
    with col1:
        search_all = st.text_input(
            "üîç Buscar munic√≠pio na tabela completa:",
            placeholder="Digite parte do nome do munic√≠pio...",
            key="search_all_data"
        )
    
    with col2:
        show_top_only = st.checkbox(
            "üìä Mostrar apenas os Top 50",
            value=True,
            help="Marque para ver apenas os 50 munic√≠pios com maior potencial"
        )
    
    # Apply filters
    display_df = df_filtered.copy()
    
    if search_all:
        display_df = display_df[display_df['nome_municipio'].str.contains(search_all, case=False, na=False)]
    
    if show_top_only:
        display_df = display_df.nlargest(50, display_col)
    else:
        display_df = display_df.sort_values(display_col, ascending=False)
    
    # Show results count
    st.markdown(f"**Mostrando {len(display_df)} munic√≠pios de {len(df_filtered)} total**")
    
    # Simple table with essential columns
    essential_columns = ['nome_municipio', display_col]
    if 'populacao_2022' in display_df.columns:
        essential_columns.append('populacao_2022')
    
    display_table = display_df[essential_columns].copy()
    display_table.columns = ['üèòÔ∏è Munic√≠pio', f'üî• {selected_type}', 'üë• Popula√ß√£o (2022)'] if len(essential_columns) == 3 else ['üèòÔ∏è Munic√≠pio', f'üî• {selected_type}']
    
    # Format numbers in the display table
    display_table[f'üî• {selected_type}'] = display_table[f'üî• {selected_type}'].apply(format_number)
    if 'üë• Popula√ß√£o (2022)' in display_table.columns:
        display_table['üë• Popula√ß√£o (2022)'] = display_table['üë• Popula√ß√£o (2022)'].apply(lambda x: f"{x:,.0f}" if pd.notna(x) else "N/A")
    
    st.dataframe(display_table, width='stretch', hide_index=True, height=400)
    
    # Download section - simplified
    st.markdown("---")
    st.markdown("### üì• Baixar os Dados")
    
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üìä Baixar Dados Filtrados", key="download_simple_filtered"):
            csv = display_df[essential_columns].to_csv(index=False)
            st.download_button(
                "üíæ Clique para Baixar",
                csv,
                f"biogas_{selected_type.lower().replace(' ', '_')}_municipios.csv",
                "text/csv",
                key="download_simple_btn"
            )
    
    with col2:
        if st.button("üìà Baixar Dados Completos", key="download_simple_complete"):
            csv = df.to_csv(index=False)
            st.download_button(
                "üíæ Clique para Baixar",
                csv,
                "biogas_dados_completos_sp.csv",
                "text/csv",
                key="download_complete_simple_btn"
            )
    
    # Help section
    st.markdown("---")
    st.markdown("### ‚ùì Precisa de Ajuda?")
    
    with st.expander("ü§î Como interpretar os dados?"):
        st.markdown("""
        **üìä Potencial de Biog√°s (Nm¬≥/ano):**
        - Representa quanto biog√°s pode ser produzido por ano
        - Nm¬≥ = Metros c√∫bicos normalizados (unidade padr√£o para gases)
        - Valores maiores = maior potencial energ√©tico
        
        **üèÜ Rankings:**
        - Mostram quais munic√≠pios t√™m maior potencial
        - √ötil para identificar oportunidades de investimento
        
        **üìà Distribui√ß√£o:**
        - Mostra como os valores est√£o espalhados
        - Ajuda a entender se poucos munic√≠pios concentram o potencial
        
        **üîç Compara√ß√£o:**
        - Permite analisar munic√≠pios espec√≠ficos lado a lado
        - √ötil para estudos regionais ou decis√µes de investimento
        """)
    
    with st.expander("üí° Dicas para explorar melhor"):
        st.markdown("""
        **Para iniciantes:**
        1. Comece sempre com "Potencial Total" para ter uma vis√£o geral
        2. Use o ranking para identificar os munic√≠pios mais promissores
        3. Compare munic√≠pios da sua regi√£o de interesse
        
        **Para an√°lises mais profundas:**
        1. Explore tipos espec√≠ficos de res√≠duos (agr√≠cola, pecu√°rio, urbano)
        2. Use a busca para encontrar munic√≠pios espec√≠ficos
        3. Baixe os dados para an√°lises externas
        
        **Interpreta√ß√£o dos resultados:**
        - Valores altos n√£o significam automaticamente viabilidade econ√¥mica
        - Considere tamb√©m fatores como log√≠stica e mercado local
        - Use os dados como ponto de partida para estudos mais detalhados
        """)
    
    # Footer with data source info
    st.markdown("---")
    st.info("""
    üìã **Sobre os dados:** Os dados apresentados s√£o baseados em estimativas de potencial te√≥rico de produ√ß√£o de biog√°s 
    a partir de diferentes tipos de res√≠duos org√¢nicos nos 645 munic√≠pios do estado de S√£o Paulo. 
    Para projetos reais, recomenda-se estudos de viabilidade t√©cnica e econ√¥mica espec√≠ficos.
    """)

def page_analysis():
    """User-Friendly Residue Analysis - Designed for Non-Technical Users"""
    
    # Welcome header with clear instructions
    st.markdown("""
    <div style='background: linear-gradient(135deg, #FF6B35 0%, #F7931E 100%); 
                color: white; padding: 2rem; margin: -1rem -1rem 2rem -1rem;
                text-align: center; border-radius: 0 0 20px 20px;'>
        <h1 style='margin: 0; font-size: 2.5rem;'>üìä An√°lise de Res√≠duos</h1>
        <p style='margin: 10px 0 0 0; font-size: 1.2rem; opacity: 0.9;'>
            Compare diferentes tipos de res√≠duos e descubra padr√µes interessantes!
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    df = load_municipalities()
    
    if df.empty:
        st.error("‚ùå Dados n√£o encontrados.")
        return
    
    # Step-by-step guided analysis
    st.markdown("### üéØ Passo 1: Escolha o Tipo de An√°lise")
    
    analysis_type = st.selectbox(
        "O que voc√™ gostaria de analisar?",
        [
            "üèÜ Comparar Tipos de Res√≠duos",
            "üåç Analisar por Regi√£o",
            "üîç Encontrar Padr√µes e Correla√ß√µes",
            "üìà An√°lise de Portf√≥lio Municipal",
            "üöÄ An√°lise Avan√ßada de Oportunidades",
            "üí° Insights Inteligentes e Recomenda√ß√µes"
        ],
        help="Cada tipo de an√°lise oferece insights diferentes sobre os dados"
    )
    
    st.markdown("---")
    
    # Analysis Type 1: Compare Residue Types
    if analysis_type == "üèÜ Comparar Tipos de Res√≠duos":
        st.markdown("### üìä Passo 2: Compare Diferentes Tipos de Res√≠duos")
        st.markdown("*Veja qual tipo de res√≠duo tem maior potencial em S√£o Paulo*")
        
        # Group residues by category for easier selection
        col1, col2 = st.columns([3, 1])
        
        with col1:
            st.markdown("""
            **Selecione as categorias que voc√™ quer comparar:**
            - üåæ **Agr√≠colas**: Cana, soja, milho, caf√©, citros
            - üêÑ **Pecu√°rios**: Bovinos, su√≠nos, aves, piscicultura
            - üèôÔ∏è **Urbanos**: Lixo urbano e poda de √°rvores
            - üìä **Totais**: Somas por categoria
            """)
            
            # Organized selection
            categories = {
                "üìä Totais": ["Potencial Total", "Total Agr√≠cola", "Total Pecu√°ria"],
                "üåæ Agr√≠colas": ["Cana-de-a√ß√∫car", "Soja", "Milho", "Caf√©", "Citros"],
                "üêÑ Pecu√°rios": ["Bovinos", "Su√≠nos", "Aves", "Piscicultura"],
                "üèôÔ∏è Urbanos": ["Res√≠duos Urbanos", "Res√≠duos Poda"]
            }
            
            selected_category = st.radio(
                "Escolha uma categoria para comparar:",
                list(categories.keys()),
                key="residue_category"
            )
            
            selected_residues = st.multiselect(
                f"Selecione os tipos de {selected_category.split(' ')[1].lower()}:",
                categories[selected_category],
                default=categories[selected_category][:3] if len(categories[selected_category]) >= 3 else categories[selected_category],
                key="selected_residues_comparison"
            )
        
        with col2:
            st.info("""
            üí° **Dica:**
            
            Comece comparando os "Totais" para ter uma vis√£o geral, depois explore categorias espec√≠ficas!
            """)
        
        if selected_residues:
            # Create comparison data
            comparison_data = []
            total_state_potential = 0
            
            for residue_type in selected_residues:
                col_name = RESIDUE_OPTIONS[residue_type]
                if col_name in df.columns:
                    # Calculate statistics
                    total = df[col_name].sum()
                    avg = df[col_name].mean()
                    municipalities_with_data = len(df[df[col_name] > 0])
                    max_municipality = df.loc[df[col_name].idxmax(), 'nome_municipio'] if total > 0 else "N/A"
                    
                    comparison_data.append({
                        'Tipo de Res√≠duo': residue_type,
                        'Potencial Total': total,
                        'Potencial M√©dio': avg,
                        'Munic√≠pios com Dados': municipalities_with_data,
                        'Munic√≠pio L√≠der': max_municipality
                    })
                    total_state_potential += total
        
        if comparison_data:
                comp_df = pd.DataFrame(comparison_data)
                
                # Show summary metrics
                st.markdown("### üìà Passo 3: Resultados da Compara√ß√£o")
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric(
                        "üî• Potencial Total Combinado",
                        f"{total_state_potential/1_000_000:.1f}M Nm¬≥/ano",
                        help="Soma de todos os tipos selecionados"
                    )
                with col2:
                    best_type = comp_df.loc[comp_df['Potencial Total'].idxmax(), 'Tipo de Res√≠duo']
                    st.metric(
                        "üèÜ Tipo L√≠der",
                        best_type,
                        help="Tipo com maior potencial total"
                    )
                with col3:
                    avg_municipalities = comp_df['Munic√≠pios com Dados'].mean()
                    st.metric(
                        "üìç M√©dia de Munic√≠pios",
                        f"{avg_municipalities:.0f}",
                        help="M√©dia de munic√≠pios com dados por tipo"
                    )
                
                # Visual comparisons
                st.markdown("#### üìä Compara√ß√£o Visual")
                
                # Tabs for different views
                comp_tabs = st.tabs(["üèÜ Potencial Total", "üìä Potencial M√©dio", "üìç Cobertura Municipal"])
                
                with comp_tabs[0]:
                    fig_total = px.bar(
                        comp_df,
                        x='Tipo de Res√≠duo',
                        y='Potencial Total',
                        title="Potencial Total por Tipo de Res√≠duo",
                        labels={'Potencial Total': 'Potencial (Nm¬≥/ano)'},
                        color='Potencial Total',
                        color_continuous_scale='Oranges'
                    )
                    fig_total.update_layout(height=500, xaxis_tickangle=-45)
                    st.plotly_chart(fig_total, width='stretch')
                    
                    # Add percentage breakdown
                    comp_df_pct = comp_df.copy()
                    comp_df_pct['Percentual'] = (comp_df_pct['Potencial Total'] / comp_df_pct['Potencial Total'].sum() * 100).round(1)
                    
                    st.markdown("**üìã Distribui√ß√£o Percentual:**")
                    for _, row in comp_df_pct.iterrows():
                        st.write(f"‚Ä¢ **{row['Tipo de Res√≠duo']}**: {row['Percentual']:.1f}% do total")
                
                with comp_tabs[1]:
                    fig_avg = px.bar(
                        comp_df,
                        x='Tipo de Res√≠duo',
                        y='Potencial M√©dio',
                        title="Potencial M√©dio por Munic√≠pio por Tipo de Res√≠duo",
                        labels={'Potencial M√©dio': 'Potencial M√©dio (Nm¬≥/ano)'},
                        color='Potencial M√©dio',
                        color_continuous_scale='Blues'
                    )
                    fig_avg.update_layout(height=500, xaxis_tickangle=-45)
                    st.plotly_chart(fig_avg, width='stretch')
                    
                    st.markdown("**üìñ O que isso significa:**")
                    st.markdown("O potencial m√©dio mostra quanto cada munic√≠pio produz em m√©dia para cada tipo de res√≠duo. Valores altos indicam que quando um munic√≠pio tem esse tipo de res√≠duo, ele tende a ter bastante.")
                
                with comp_tabs[2]:
                    fig_coverage = px.bar(
                        comp_df,
                        x='Tipo de Res√≠duo',
                        y='Munic√≠pios com Dados',
                        title="N√∫mero de Munic√≠pios com Cada Tipo de Res√≠duo",
                        labels={'Munic√≠pios com Dados': 'Quantidade de Munic√≠pios'},
                        color='Munic√≠pios com Dados',
                        color_continuous_scale='Greens'
                    )
                    fig_coverage.update_layout(height=500, xaxis_tickangle=-45)
                    st.plotly_chart(fig_coverage, width='stretch')
                    
                    st.markdown("**üìç Cobertura Territorial:**")
                    for _, row in comp_df.iterrows():
                        percentage = (row['Munic√≠pios com Dados'] / 645) * 100
                        st.write(f"‚Ä¢ **{row['Tipo de Res√≠duo']}**: {row['Munic√≠pios com Dados']} munic√≠pios ({percentage:.1f}% do estado)")
                
                # Detailed table
                st.markdown("#### üìã Tabela Detalhada")
                display_comp_df = comp_df.copy()
                display_comp_df['Potencial Total'] = display_comp_df['Potencial Total'].apply(format_number)
                display_comp_df['Potencial M√©dio'] = display_comp_df['Potencial M√©dio'].apply(format_number)
                st.dataframe(display_comp_df, width='stretch', hide_index=True)
    
    # Analysis Type 2: Regional Analysis
    elif analysis_type == "üåç Analisar por Regi√£o":
        st.markdown("### üó∫Ô∏è Passo 2: An√°lise Regional")
        st.markdown("*Descubra como o potencial de biog√°s varia geograficamente*")
        
        # Since we don't have region data, we'll create analysis by municipality size
        col1, col2 = st.columns([3, 1])
        
        with col1:
            region_analysis_type = st.selectbox(
                "Que tipo de an√°lise regional voc√™ quer fazer?",
                [
                    "üìè Por Tamanho de Munic√≠pio (Popula√ß√£o)",
                    "üèÜ Top Regi√µes vs Resto do Estado"
                ],
                key="region_analysis_type"
            )
            
            selected_residue_regional = st.selectbox(
                "Escolha o tipo de res√≠duo para analisar:",
                list(RESIDUE_OPTIONS.keys()),
                key="regional_residue_select"
            )
        
        with col2:
            st.info("""
            üí° **An√°lise Regional:**
            
            Entenda como o potencial se distribui geograficamente e identifique regi√µes de oportunidade!
            """)
        
        residue_col = RESIDUE_OPTIONS[selected_residue_regional]
        df_regional = df[df[residue_col] > 0].copy()
        
        if not df_regional.empty:
            if region_analysis_type == "üìè Por Tamanho de Munic√≠pio (Popula√ß√£o)":
                if 'populacao_2022' in df_regional.columns:
                    # Create population ranges
                    df_regional['faixa_pop'] = pd.cut(
                        df_regional['populacao_2022'],
                        bins=[0, 20000, 50000, 100000, 500000, float('inf')],
                        labels=['Pequeno (<20K)', 'M√©dio (20-50K)', 'Grande (50-100K)', 'Muito Grande (100-500K)', 'Metr√≥pole (>500K)']
                    )
                    
                    # Group analysis
                    regional_summary = df_regional.groupby('faixa_pop').agg({
                        residue_col: ['sum', 'mean', 'count'],
                        'populacao_2022': 'sum'
                    }).round(0)
                    
                    regional_summary.columns = ['Potencial Total', 'Potencial M√©dio', 'Qtd Munic√≠pios', 'Popula√ß√£o Total']
                    regional_summary = regional_summary.reset_index()
                    
                    st.markdown("### üìà Passo 3: Resultados por Tamanho de Munic√≠pio")
                    
                    # Show summary
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        best_category = regional_summary.loc[regional_summary['Potencial Total'].idxmax(), 'faixa_pop']
                        st.metric("üèÜ Categoria L√≠der", best_category)
                    with col2:
                        total_municipalities = regional_summary['Qtd Munic√≠pios'].sum()
                        st.metric("üìç Total de Munic√≠pios", f"{total_municipalities:,.0f}")
                    with col3:
                        avg_per_category = regional_summary['Potencial M√©dio'].mean()
                        st.metric("üìä Potencial M√©dio Geral", format_number(avg_per_category))
                    
                    # Visualizations
                    fig_regional = px.bar(
                        regional_summary,
                        x='faixa_pop',
                        y='Potencial Total',
                        title=f"Potencial Total de {selected_residue_regional} por Tamanho de Munic√≠pio",
                        labels={'Potencial Total': 'Potencial (Nm¬≥/ano)', 'faixa_pop': 'Tamanho do Munic√≠pio'},
                        color='Potencial Total',
                        color_continuous_scale='Viridis'
                    )
                    fig_regional.update_layout(height=500)
                    st.plotly_chart(fig_regional, width='stretch')
                    
                    # Show detailed table
                    display_regional = regional_summary.copy()
                    display_regional['Potencial Total'] = display_regional['Potencial Total'].apply(format_number)
                    display_regional['Potencial M√©dio'] = display_regional['Potencial M√©dio'].apply(format_number)
                    display_regional['Popula√ß√£o Total'] = display_regional['Popula√ß√£o Total'].apply(lambda x: f"{x:,.0f}")
                    display_regional.columns = ['Tamanho do Munic√≠pio', 'Potencial Total', 'Potencial M√©dio', 'Qtd Munic√≠pios', 'Popula√ß√£o Total']
                    st.dataframe(display_regional, width='stretch', hide_index=True)
            
            elif region_analysis_type == "üèÜ Top Regi√µes vs Resto do Estado":
                # Analysis of top municipalities vs others
                top_n = st.slider("Quantos munic√≠pios considerar como 'Top'?", 5, 50, 20)
                
                df_sorted = df_regional.sort_values(residue_col, ascending=False)
                top_municipalities = df_sorted.head(top_n)
                other_municipalities = df_sorted.tail(len(df_sorted) - top_n)
                
                comparison_data = [
                    {
                        'Grupo': f'Top {top_n} Munic√≠pios',
                        'Potencial Total': top_municipalities[residue_col].sum(),
                        'Potencial M√©dio': top_municipalities[residue_col].mean(),
                        'Quantidade': len(top_municipalities)
                    },
                    {
                        'Grupo': f'Outros {len(other_municipalities)} Munic√≠pios',
                        'Potencial Total': other_municipalities[residue_col].sum(),
                        'Potencial M√©dio': other_municipalities[residue_col].mean(),
                        'Quantidade': len(other_municipalities)
                    }
                ]
                
                comparison_df = pd.DataFrame(comparison_data)
                
                st.markdown(f"### üìà Passo 3: Top {top_n} vs Resto do Estado")
                
                # Show concentration metrics
                top_percentage = (comparison_df.iloc[0]['Potencial Total'] / df_regional[residue_col].sum()) * 100
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric(
                        f"üéØ Concentra√ß√£o nos Top {top_n}",
                        f"{top_percentage:.1f}%",
                        help=f"Percentual do potencial total concentrado nos {top_n} melhores munic√≠pios"
                    )
                with col2:
                    ratio = comparison_df.iloc[0]['Potencial M√©dio'] / comparison_df.iloc[1]['Potencial M√©dio']
                    st.metric(
                        "üìä Diferen√ßa M√©dia",
                        f"{ratio:.1f}x",
                        help="Quantas vezes o potencial m√©dio dos top √© maior que os outros"
                    )
                with col3:
                    st.metric(
                        "üèòÔ∏è Total de Munic√≠pios",
                        f"{len(df_regional):,}",
                        help="Total de munic√≠pios com dados para este res√≠duo"
                    )
                
                # Visualization
                fig_comparison = px.bar(
                    comparison_df,
                    x='Grupo',
                    y='Potencial Total',
                    title=f"Concentra√ß√£o do Potencial - {selected_residue_regional}",
                    labels={'Potencial Total': 'Potencial (Nm¬≥/ano)'},
                    color='Potencial Total',
                    color_continuous_scale='Reds'
                )
                st.plotly_chart(fig_comparison, width='stretch')
                
                # Show top municipalities
                st.markdown(f"#### üèÜ Lista dos Top {top_n} Munic√≠pios")
                top_display = top_municipalities[['nome_municipio', residue_col]].copy()
                top_display[residue_col] = top_display[residue_col].apply(format_number)
                top_display.columns = ['Munic√≠pio', f'{selected_residue_regional} (Nm¬≥/ano)']
                top_display = top_display.reset_index(drop=True)
                top_display.index += 1
                st.dataframe(top_display, width='stretch')
    
    # Analysis Type 3: Patterns and Correlations
    elif analysis_type == "üîç Encontrar Padr√µes e Correla√ß√µes":
        st.markdown("### üîó Passo 2: An√°lise de Padr√µes")
        st.markdown("*Descubra rela√ß√µes interessantes entre diferentes tipos de res√≠duos*")
        
        col1, col2 = st.columns([3, 1])
        
        with col1:
            correlation_type = st.selectbox(
                "Que tipo de padr√£o voc√™ quer descobrir?",
                [
                    "üîó Correla√ß√£o entre Tipos de Res√≠duos",
                    "üë• Rela√ß√£o com Popula√ß√£o",
                    "üèÜ Munic√≠pios Multiespecializados"
                ],
                key="correlation_analysis_type"
            )
        
        with col2:
            st.info("""
            üí° **Padr√µes:**
            
            Encontre rela√ß√µes que podem indicar oportunidades de neg√≥cio ou sinergia!
            """)
        
        if correlation_type == "üîó Correla√ß√£o entre Tipos de Res√≠duos":
            st.markdown("#### Escolha dois tipos de res√≠duos para comparar:")
            
            col_a, col_b = st.columns(2)
            with col_a:
                residue_a = st.selectbox("Primeiro tipo:", list(RESIDUE_OPTIONS.keys()), key="corr_a")
            with col_b:
                residue_b = st.selectbox("Segundo tipo:", list(RESIDUE_OPTIONS.keys()), index=1, key="corr_b")
            
            if residue_a != residue_b:
                col_a_name = RESIDUE_OPTIONS[residue_a]
                col_b_name = RESIDUE_OPTIONS[residue_b]
                
                # Filter data with both types
                df_corr = df[(df[col_a_name] > 0) & (df[col_b_name] > 0)].copy()
                
                if len(df_corr) > 5:  # Need at least 5 points for correlation
                    correlation = df_corr[col_a_name].corr(df_corr[col_b_name])
                    
                    st.markdown("### üìà Passo 3: Resultado da Correla√ß√£o")
                    
                    # Interpret correlation
                    if correlation > 0.7:
                        interpretation = "üî• **Forte correla√ß√£o positiva** - Munic√≠pios que t√™m muito de um tipo geralmente t√™m muito do outro!"
                        color = "green"
                    elif correlation > 0.3:
                        interpretation = "üìä **Correla√ß√£o moderada** - H√° alguma rela√ß√£o entre os dois tipos."
                        color = "orange"
                    elif correlation > -0.3:
                        interpretation = "ü§∑ **Pouca correla√ß√£o** - Os dois tipos s√£o independentes."
                        color = "gray"
                    else:
                        interpretation = "‚ÜîÔ∏è **Correla√ß√£o negativa** - Quando um √© alto, o outro tende a ser baixo."
                        color = "red"
                    
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("üîó Correla√ß√£o", f"{correlation:.3f}")
                    with col2:
                        st.metric("üìç Munic√≠pios Analisados", len(df_corr))
                    with col3:
                        st.metric("üìä For√ßa da Rela√ß√£o", 
                                f"{'Forte' if abs(correlation) > 0.7 else 'Moderada' if abs(correlation) > 0.3 else 'Fraca'}")
                    
                    st.markdown(f"**{interpretation}**")
                    
                    # Scatter plot with error handling
                    try:
                        fig_scatter = px.scatter(
                            df_corr,
                            x=col_a_name,
                            y=col_b_name,
                            hover_name='nome_municipio',
                            title=f"Correla√ß√£o: {residue_a} vs {residue_b}",
                            labels={
                                col_a_name: f"{residue_a} (Nm¬≥/ano)",
                                col_b_name: f"{residue_b} (Nm¬≥/ano)"
                            },
                            trendline="ols"
                        )
                    except ImportError:
                        # Fallback without trendline if statsmodels is not available
                        st.warning("‚ö†Ô∏è Linha de tend√™ncia n√£o dispon√≠vel (instale statsmodels)")
                        fig_scatter = px.scatter(
                            df_corr,
                            x=col_a_name,
                            y=col_b_name,
                            hover_name='nome_municipio',
                            title=f"Correla√ß√£o: {residue_a} vs {residue_b}",
                            labels={
                                col_a_name: f"{residue_a} (Nm¬≥/ano)",
                                col_b_name: f"{residue_b} (Nm¬≥/ano)"
                            }
                        )
                    
                    # Enhanced styling
                    fig_scatter.update_traces(
                        marker=dict(size=8, opacity=0.6, line=dict(width=1, color='white'))
                    )
                    fig_scatter.update_layout(
                        height=500,
                        showlegend=True,
                        plot_bgcolor='rgba(0,0,0,0)',
                        paper_bgcolor='rgba(0,0,0,0)'
                    )
                    st.plotly_chart(fig_scatter, width='stretch')
                    
                    # Show municipalities with both high values
                    if correlation > 0.3:
                        st.markdown("#### üèÜ Munic√≠pios que se Destacam nos Dois Tipos")
                        # Get municipalities in top quartile for both
                        q75_a = df_corr[col_a_name].quantile(0.75)
                        q75_b = df_corr[col_b_name].quantile(0.75)
                        
                        top_both = df_corr[(df_corr[col_a_name] >= q75_a) & (df_corr[col_b_name] >= q75_b)]
                        
                        if not top_both.empty:
                            top_display = top_both[['nome_municipio', col_a_name, col_b_name]].copy()
                            top_display[col_a_name] = top_display[col_a_name].apply(format_number)
                            top_display[col_b_name] = top_display[col_b_name].apply(format_number)
                            top_display.columns = ['Munic√≠pio', residue_a, residue_b]
                            st.dataframe(top_display, width='stretch', hide_index=True)
                        else:
                            st.write("Nenhum munic√≠pio se destaca simultaneamente nos dois tipos.")
                else:
                    st.warning("‚ö†Ô∏è Poucos munic√≠pios t√™m dados para ambos os tipos. Tente outras combina√ß√µes.")
        
        elif correlation_type == "üë• Rela√ß√£o com Popula√ß√£o":
            st.markdown("#### Veja como o potencial se relaciona com o tamanho da popula√ß√£o:")
            
            selected_residue_pop = st.selectbox(
                "Escolha o tipo de res√≠duo:",
                list(RESIDUE_OPTIONS.keys()),
                key="population_correlation_residue"
            )
            
            residue_col_pop = RESIDUE_OPTIONS[selected_residue_pop]
            
            if 'populacao_2022' in df.columns:
                df_pop = df[(df[residue_col_pop] > 0) & (df['populacao_2022'] > 0)].copy()
                
                if not df_pop.empty:
                    correlation_pop = df_pop[residue_col_pop].corr(df_pop['populacao_2022'])
                    
                    st.markdown("### üìà Passo 3: Rela√ß√£o com Popula√ß√£o")
                    
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("üîó Correla√ß√£o", f"{correlation_pop:.3f}")
                    with col2:
                        st.metric("üìç Munic√≠pios", len(df_pop))
                    with col3:
                        avg_per_capita = (df_pop[residue_col_pop] / df_pop['populacao_2022']).mean()
                        st.metric("üë§ M√©dia per Capita", f"{avg_per_capita:.2f} Nm¬≥/hab/ano")
                    
                    # Interpretation
                    if correlation_pop > 0.5:
                        st.success("‚úÖ **Correla√ß√£o positiva forte** - Munic√≠pios maiores tendem a ter mais potencial!")
                    elif correlation_pop > 0.2:
                        st.info("üìä **Correla√ß√£o moderada** - H√° alguma rela√ß√£o com o tamanho da popula√ß√£o.")
                    else:
                        st.warning("ü§∑ **Pouca correla√ß√£o** - O potencial n√£o depende muito do tamanho da popula√ß√£o.")
                    
                    # Scatter plot with enhanced styling
                    try:
                        fig_pop = px.scatter(
                            df_pop,
                            x='populacao_2022',
                            y=residue_col_pop,
                            hover_name='nome_municipio',
                            title=f"Popula√ß√£o vs {selected_residue_pop}",
                            labels={
                                'populacao_2022': 'Popula√ß√£o (2022)',
                                residue_col_pop: f'{selected_residue_pop} (Nm¬≥/ano)'
                            },
                            trendline="ols",
                            size=residue_col_pop,
                            color=residue_col_pop,
                            color_continuous_scale='Viridis'
                        )
                    except ImportError:
                        # Fallback without trendline if statsmodels is not available
                        fig_pop = px.scatter(
                            df_pop,
                            x='populacao_2022',
                            y=residue_col_pop,
                            hover_name='nome_municipio',
                            title=f"Popula√ß√£o vs {selected_residue_pop}",
                            labels={
                                'populacao_2022': 'Popula√ß√£o (2022)',
                                residue_col_pop: f'{selected_residue_pop} (Nm¬≥/ano)'
                            },
                            size=residue_col_pop,
                            color=residue_col_pop,
                            color_continuous_scale='Viridis'
                        )
                    
                    fig_pop.update_layout(
                        height=500,
                        plot_bgcolor='rgba(0,0,0,0)',
                        paper_bgcolor='rgba(0,0,0,0)'
                    )
                    st.plotly_chart(fig_pop, width='stretch')
        
        elif correlation_type == "üèÜ Munic√≠pios Multiespecializados":
            st.markdown("#### Descubra quais munic√≠pios se destacam em v√°rios tipos de res√≠duos:")
            
            # Calculate how many types each municipality has significant potential
            residue_columns = [col for col in RESIDUE_OPTIONS.values() if col in df.columns]
            
            # Define "significant" as being in top 25% for each type
            df_multi = df.copy()
            specialization_scores = []
            
            for _, row in df_multi.iterrows():
                score = 0
                types_with_potential = []
                
                for label, col in RESIDUE_OPTIONS.items():
                    if col in df.columns and row[col] > 0:
                        # Check if municipality is in top 25% for this type
                        threshold = df[col].quantile(0.75)
                        if row[col] >= threshold:
                            score += 1
                            types_with_potential.append(label)
                
                specialization_scores.append({
                    'nome_municipio': row['nome_municipio'],
                    'score_especializacao': score,
                    'tipos_destacados': ', '.join(types_with_potential) if types_with_potential else 'Nenhum',
                    'total_potencial': row.get('total_final_nm_ano', 0)
                })
            
            specialization_df = pd.DataFrame(specialization_scores)
            specialization_df = specialization_df[specialization_df['score_especializacao'] > 0].sort_values('score_especializacao', ascending=False)
            
            st.markdown("### üìà Passo 3: Ranking de Multiespecializa√ß√£o")
            
            if not specialization_df.empty:
                col1, col2, col3 = st.columns(3)
                with col1:
                    max_score = specialization_df['score_especializacao'].max()
                    st.metric("üèÜ M√°ximo de Especializa√ß√µes", f"{max_score} tipos")
                with col2:
                    multi_specialists = len(specialization_df[specialization_df['score_especializacao'] >= 3])
                    st.metric("üåü Multiespecialistas", f"{multi_specialists} munic√≠pios")
                with col3:
                    avg_score = specialization_df['score_especializacao'].mean()
                    st.metric("üìä M√©dia de Especializa√ß√µes", f"{avg_score:.1f}")
                
                # Show top multispcialized municipalities
                top_multi = specialization_df.head(20)
                
                ranking_multi = []
                for i, (_, row) in enumerate(top_multi.iterrows(), 1):
                    ranking_multi.append({
                        "üèÖ Posi√ß√£o": f"{i}¬∫",
                        "üèòÔ∏è Munic√≠pio": row['nome_municipio'],
                        "üåü Especializa√ß√µes": f"{row['score_especializacao']} tipos",
                        "üìã Tipos Destacados": row['tipos_destacados'],
                        "üî• Potencial Total": format_number(row['total_potencial'])
                    })
                
                ranking_multi_df = pd.DataFrame(ranking_multi)
                st.dataframe(ranking_multi_df, width='stretch', hide_index=True)
                
                # Visualization
                fig_multi = px.histogram(
                    specialization_df,
                    x='score_especializacao',
                    title="Distribui√ß√£o de Especializa√ß√µes",
                    labels={'score_especializacao': 'N√∫mero de Especializa√ß√µes', 'count': 'Quantidade de Munic√≠pios'},
                    nbins=max_score
                )
                st.plotly_chart(fig_multi, width='stretch')
            else:
                st.info("Nenhum munic√≠pio se destaca significativamente em m√∫ltiplos tipos de res√≠duos.")
    
    # Analysis Type 4: Municipal Portfolio
    elif analysis_type == "üìà An√°lise de Portf√≥lio Municipal":
        st.markdown("### üèòÔ∏è Passo 2: An√°lise de Portf√≥lio Municipal")
        st.markdown("*Descubra quais munic√≠pios t√™m o portf√≥lio mais diversificado de res√≠duos*")
        
        # Calculate diversity score for each municipality
        residue_columns = [col for col in RESIDUE_OPTIONS.values() if col in df.columns]
        
        df_portfolio = df.copy()
        
        # Calculate diversity metrics
        df_portfolio['tipos_com_dados'] = (df_portfolio[residue_columns] > 0).sum(axis=1)
        df_portfolio['potencial_total_real'] = df_portfolio[residue_columns].sum(axis=1)
        df_portfolio['diversidade_score'] = df_portfolio['tipos_com_dados'] / len(residue_columns)
        
        # Filter municipalities with at least some data
        df_portfolio = df_portfolio[df_portfolio['potencial_total_real'] > 0]
        
        st.markdown("### üìä Passo 3: Ranking de Diversifica√ß√£o")
        
        portfolio_analysis = st.selectbox(
            "Como voc√™ quer analisar os portf√≥lios municipais?",
            [
                "üåü Munic√≠pios Mais Diversificados",
                "üéØ Munic√≠pios Especializados",
                "‚öñÔ∏è Diversifica√ß√£o vs Potencial Total"
            ]
        )
        
        if portfolio_analysis == "üåü Munic√≠pios Mais Diversificados":
            # Most diversified municipalities
            top_diversified = df_portfolio.nlargest(20, 'diversidade_score')
            
            col1, col2, col3 = st.columns(3)
            with col1:
                max_types = top_diversified['tipos_com_dados'].max()
                st.metric("üèÜ M√°ximo de Tipos", f"{max_types}/{len(residue_columns)}")
            with col2:
                avg_diversity = top_diversified['diversidade_score'].mean()
                st.metric("üìä Diversidade M√©dia", f"{avg_diversity:.1%}")
            with col3:
                total_municipalities = len(df_portfolio)
                st.metric("üìç Total de Munic√≠pios", total_municipalities)
            
            # Show ranking
            ranking_data = []
            for i, (_, row) in enumerate(top_diversified.iterrows(), 1):
                ranking_data.append({
                    "üèÖ Posi√ß√£o": f"{i}¬∫",
                    "üèòÔ∏è Munic√≠pio": row['nome_municipio'],
                    "üåü Tipos de Res√≠duos": f"{row['tipos_com_dados']}/{len(residue_columns)}",
                    "üìä Score de Diversidade": f"{row['diversidade_score']:.1%}",
                    "üî• Potencial Total": format_number(row['potencial_total_real'])
                })
            
            ranking_df = pd.DataFrame(ranking_data)
            st.dataframe(ranking_df, width='stretch', hide_index=True)
            
            # Visualization
            fig_diversity = px.scatter(
                top_diversified,
                x='tipos_com_dados',
                y='potencial_total_real',
                hover_name='nome_municipio',
                title="Diversifica√ß√£o vs Potencial Total",
                labels={
                    'tipos_com_dados': 'N√∫mero de Tipos de Res√≠duos',
                    'potencial_total_real': 'Potencial Total (Nm¬≥/ano)'
                },
                size='potencial_total_real',
                color='diversidade_score',
                color_continuous_scale='Viridis'
            )
            st.plotly_chart(fig_diversity, width='stretch')
        
        elif portfolio_analysis == "üéØ Munic√≠pios Especializados":
            # Municipalities specialized in few types but with high potential
            specialized = df_portfolio[df_portfolio['tipos_com_dados'] <= 3].nlargest(20, 'potencial_total_real')
            
            if not specialized.empty:
                col1, col2, col3 = st.columns(3)
                with col1:
                    avg_types = specialized['tipos_com_dados'].mean()
                    st.metric("üìä M√©dia de Tipos", f"{avg_types:.1f}")
                with col2:
                    total_potential = specialized['potencial_total_real'].sum()
                    st.metric("üî• Potencial Total", f"{total_potential/1_000_000:.1f}M Nm¬≥/ano")
                with col3:
                    st.metric("üéØ Munic√≠pios Especializados", len(specialized))
                
                # Show specialized municipalities
                specialized_ranking = []
                for i, (_, row) in enumerate(specialized.iterrows(), 1):
                    # Find which types this municipality specializes in
                    specialized_types = []
                    for label, col in RESIDUE_OPTIONS.items():
                        if col in df.columns and row[col] > 0:
                            specialized_types.append(label)
                    
                    specialized_ranking.append({
                        "üèÖ Posi√ß√£o": f"{i}¬∫",
                        "üèòÔ∏è Munic√≠pio": row['nome_municipio'],
                        "üéØ Tipos": f"{row['tipos_com_dados']} tipos",
                        "üìã Especializa√ß√£o": ', '.join(specialized_types[:3]),  # Show first 3
                        "üî• Potencial Total": format_number(row['potencial_total_real'])
                    })
                
                specialized_df = pd.DataFrame(specialized_ranking)
                st.dataframe(specialized_df, width='stretch', hide_index=True)
            else:
                st.info("N√£o h√° munic√≠pios com especializa√ß√£o em poucos tipos.")
        
        elif portfolio_analysis == "‚öñÔ∏è Diversifica√ß√£o vs Potencial Total":
            # Analysis of relationship between diversification and total potential
            correlation_div = df_portfolio['diversidade_score'].corr(df_portfolio['potencial_total_real'])
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üîó Correla√ß√£o", f"{correlation_div:.3f}")
            with col2:
                high_div_high_pot = len(df_portfolio[
                    (df_portfolio['diversidade_score'] > df_portfolio['diversidade_score'].quantile(0.75)) &
                    (df_portfolio['potencial_total_real'] > df_portfolio['potencial_total_real'].quantile(0.75))
                ])
                st.metric("üåü Alta Div. + Alto Pot.", high_div_high_pot)
            with col3:
                avg_potential_high_div = df_portfolio[
                    df_portfolio['diversidade_score'] > df_portfolio['diversidade_score'].quantile(0.75)
                ]['potencial_total_real'].mean()
                st.metric("üìä Pot. M√©dio (Alta Div.)", format_number(avg_potential_high_div))
            
            # Scatter plot with error handling
            try:
                fig_div_pot = px.scatter(
                    df_portfolio,
                    x='diversidade_score',
                    y='potencial_total_real',
                    hover_name='nome_municipio',
                    title="Diversifica√ß√£o vs Potencial Total",
                    labels={
                        'diversidade_score': 'Score de Diversifica√ß√£o',
                        'potencial_total_real': 'Potencial Total (Nm¬≥/ano)'
                    },
                    trendline="ols",
                    color='tipos_com_dados',
                    color_continuous_scale='Plasma'
                )
            except ImportError:
                # Fallback without trendline if statsmodels is not available
                fig_div_pot = px.scatter(
                    df_portfolio,
                    x='diversidade_score',
                    y='potencial_total_real',
                    hover_name='nome_municipio',
                    title="Diversifica√ß√£o vs Potencial Total",
                    labels={
                        'diversidade_score': 'Score de Diversifica√ß√£o',
                        'potencial_total_real': 'Potencial Total (Nm¬≥/ano)'
                    },
                    color='tipos_com_dados',
                    color_continuous_scale='Plasma'
                )
            
            fig_div_pot.update_layout(
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)'
            )
            st.plotly_chart(fig_div_pot, width='stretch')
            
            # Interpretation
            if correlation_div > 0.3:
                st.success("‚úÖ **Correla√ß√£o positiva** - Munic√≠pios mais diversificados tendem a ter maior potencial total!")
            elif correlation_div > 0.1:
                st.info("üìä **Correla√ß√£o fraca** - H√° alguma rela√ß√£o entre diversifica√ß√£o e potencial.")
            else:
                st.warning("ü§∑ **Pouca correla√ß√£o** - Diversifica√ß√£o e potencial total s√£o independentes.")

    # Analysis Type 5: Advanced Opportunities
    elif analysis_type == "üöÄ An√°lise Avan√ßada de Oportunidades":
        st.markdown("### üöÄ Passo 2: Identifica√ß√£o de Oportunidades Estrat√©gicas")
        st.markdown("*Descubra oportunidades de neg√≥cio e investimento baseadas em dados avan√ßados*")
        
        opportunity_type = st.selectbox(
            "Que tipo de oportunidade voc√™ quer investigar?",
            [
                "üí∞ Munic√≠pios Subutilizados (Alto Potencial + Baixo Desenvolvimento)",
                "üéØ Clusters de Sinergia Regional",
                "üìä An√°lise de Viabilidade Econ√¥mica",
                "üîÆ Proje√ß√µes de Crescimento"
            ]
        )
        
        if opportunity_type == "üí∞ Munic√≠pios Subutilizados (Alto Potencial + Baixo Desenvolvimento)":
            st.markdown("#### üíé Joias Escondidas: Munic√≠pios com Grande Potencial Inexplorado")
            
            # Calculate development index (population + economic indicators proxy)
            df_opp = df.copy()
            df_opp = df_opp[df_opp['total_final_nm_ano'] > 0].copy()
            
            # Normalize metrics for comparison
            df_opp['potencial_normalizado'] = (df_opp['total_final_nm_ano'] - df_opp['total_final_nm_ano'].min()) / (df_opp['total_final_nm_ano'].max() - df_opp['total_final_nm_ano'].min())
            df_opp['desenvolvimento_normalizado'] = (df_opp['populacao_2022'] - df_opp['populacao_2022'].min()) / (df_opp['populacao_2022'].max() - df_opp['populacao_2022'].min())
            
            # Calculate opportunity score (high potential, low development)
            df_opp['opportunity_score'] = df_opp['potencial_normalizado'] - df_opp['desenvolvimento_normalizado']
            
            # Find top opportunities
            top_opportunities = df_opp.nlargest(15, 'opportunity_score')
            
            col1, col2, col3 = st.columns(3)
            with col1:
                avg_potential = top_opportunities['total_final_nm_ano'].mean()
                st.metric("üíé Potencial M√©dio (Oportunidades)", format_number(avg_potential))
            with col2:
                total_unexplored = top_opportunities['total_final_nm_ano'].sum()
                st.metric("üöÄ Potencial Total Subutilizado", format_number(total_unexplored))
            with col3:
                best_score = top_opportunities['opportunity_score'].max()
                st.metric("‚≠ê Melhor Score de Oportunidade", f"{best_score:.3f}")
            
            # Show ranking
            opportunities_ranking = []
            for i, (_, row) in enumerate(top_opportunities.iterrows(), 1):
                opportunities_ranking.append({
                    "üèÖ Rank": f"{i}¬∫",
                    "üíé Munic√≠pio": row['nome_municipio'],
                    "üöÄ Potencial": format_number(row['total_final_nm_ano']),
                    "üë• Popula√ß√£o": f"{row['populacao_2022']:,.0f}",
                    "‚≠ê Score": f"{row['opportunity_score']:.3f}",
                    "üåü Regi√£o": row.get('regiao_imediata', 'N/A')
                })
            
            st.markdown("#### üèÜ Top 15 Oportunidades de Investimento")
            ranking_opp_df = pd.DataFrame(opportunities_ranking)
            st.dataframe(ranking_opp_df, width='stretch', hide_index=True)
            
            # Opportunity matrix visualization
            fig_matrix = px.scatter(
                df_opp,
                x='desenvolvimento_normalizado',
                y='potencial_normalizado',
                hover_name='nome_municipio',
                title="Matriz de Oportunidades: Desenvolvimento vs Potencial",
                labels={
                    'desenvolvimento_normalizado': 'N√≠vel de Desenvolvimento (Popula√ß√£o Normalizada)',
                    'potencial_normalizado': 'Potencial de Biog√°s (Normalizado)'
                },
                color='opportunity_score',
                color_continuous_scale='RdYlGn',
                size='total_final_nm_ano'
            )
            
            # Add quadrant lines
            fig_matrix.add_hline(y=0.5, line_dash="dash", line_color="gray")
            fig_matrix.add_vline(x=0.5, line_dash="dash", line_color="gray")
            
            # Add annotations for quadrants
            fig_matrix.add_annotation(x=0.25, y=0.75, text="OPORTUNIDADES<br>PRIME", 
                                    showarrow=False, font=dict(size=12, color="green"))
            fig_matrix.add_annotation(x=0.75, y=0.75, text="DESENVOLVIDAS<br>CONSOLIDADAS", 
                                    showarrow=False, font=dict(size=12, color="blue"))
            fig_matrix.add_annotation(x=0.25, y=0.25, text="BAIXO POTENCIAL<br>EM DESENVOLVIMENTO", 
                                    showarrow=False, font=dict(size=12, color="orange"))
            fig_matrix.add_annotation(x=0.75, y=0.25, text="DESENVOLVIDAS<br>BAIXO POTENCIAL", 
                                    showarrow=False, font=dict(size=12, color="red"))
            
            fig_matrix.update_layout(height=600)
            st.plotly_chart(fig_matrix, width='stretch')
            
        elif opportunity_type == "üéØ Clusters de Sinergia Regional":
            st.markdown("#### üåç An√°lise de Clusters Regionais para Sinergia")
            
            if 'regiao_imediata' in df.columns:
                regional_analysis = df.groupby('regiao_imediata').agg({
                    'total_final_nm_ano': ['sum', 'mean', 'count'],
                    'populacao_2022': 'sum',
                    'total_agricola_nm_ano': 'sum',
                    'total_pecuaria_nm_ano': 'sum'
                }).round(0)
                
                regional_analysis.columns = ['Total_Potencial', 'Media_Potencial', 'Num_Municipios', 'Pop_Total', 'Potencial_Agri', 'Potencial_Pec']
                regional_analysis = regional_analysis.sort_values('Total_Potencial', ascending=False).head(10)
                
                st.markdown("#### üèÜ Top 10 Regi√µes para Desenvolvimento de Clusters")
                
                cluster_ranking = []
                for i, (regiao, row) in enumerate(regional_analysis.iterrows(), 1):
                    cluster_ranking.append({
                        "üèÖ Rank": f"{i}¬∫",
                        "üåç Regi√£o": regiao,
                        "üöÄ Potencial Total": format_number(row['Total_Potencial']),
                        "üèòÔ∏è Munic√≠pios": f"{int(row['Num_Municipios'])}",
                        "üë• Popula√ß√£o": f"{int(row['Pop_Total']):,}",
                        "üåæ % Agr√≠cola": f"{(row['Potencial_Agri']/row['Total_Potencial']*100):.0f}%",
                        "üêÑ % Pecu√°ria": f"{(row['Potencial_Pec']/row['Total_Potencial']*100):.0f}%"
                    })
                
                cluster_df = pd.DataFrame(cluster_ranking)
                st.dataframe(cluster_df, width='stretch', hide_index=True)
                
                # Regional potential visualization
                fig_regional = px.bar(
                    regional_analysis.reset_index(),
                    x='regiao_imediata',
                    y='Total_Potencial',
                    title="Potencial Total por Regi√£o (Top 10)",
                    labels={'Total_Potencial': 'Potencial Total (Nm¬≥/ano)', 'regiao_imediata': 'Regi√£o'},
                    color='Media_Potencial',
                    color_continuous_scale='Viridis'
                )
                fig_regional.update_xaxes(tickangle=45)
                fig_regional.update_layout(height=500)
                st.plotly_chart(fig_regional, width='stretch')

    # Analysis Type 6: Intelligent Insights
    elif analysis_type == "üí° Insights Inteligentes e Recomenda√ß√µes":
        st.markdown("### üí° Passo 2: Gera√ß√£o de Insights Automatizados")
        st.markdown("*Sistema inteligente analisa os dados e fornece recomenda√ß√µes personalizadas*")
        
        insight_type = st.selectbox(
            "Que tipo de insight voc√™ precisa?",
            [
                "üéØ Recomenda√ß√µes Personalizadas por Perfil",
                "üìä An√°lise SWOT Autom√°tica",
                "üîç Detec√ß√£o de Padr√µes Ocultos",
                "üìà Cen√°rios de Desenvolvimento"
            ]
        )
        
        if insight_type == "üéØ Recomenda√ß√µes Personalizadas por Perfil":
            st.markdown("#### üéØ Sistema de Recomenda√ß√µes Inteligente")
            
            user_profile = st.selectbox(
                "Qual √© o seu perfil/interesse?",
                [
                    "üèõÔ∏è Gestor P√∫blico Municipal",
                    "üíº Investidor/Empres√°rio",
                    "üéì Pesquisador Acad√™mico",
                    "üå± Consultor em Sustentabilidade",
                    "üè≠ Desenvolvedor de Projetos"
                ]
            )
            
            region_filter = st.selectbox(
                "Regi√£o de interesse:",
                ["üìç Todo o Estado"] + (df['regiao_imediata'].dropna().unique().tolist() if 'regiao_imediata' in df.columns else [])
            )
            
            # Filter data based on region
            df_filtered = df.copy()
            if region_filter != "üìç Todo o Estado":
                df_filtered = df_filtered[df_filtered['regiao_imediata'] == region_filter]
            
            # Generate personalized recommendations
            if user_profile == "üèõÔ∏è Gestor P√∫blico Municipal":
                st.markdown("#### üèõÔ∏è Recomenda√ß√µes para Gestores P√∫blicos")
                
                # Priority municipalities for public policy
                high_potential = df_filtered[df_filtered['total_final_nm_ano'] > df_filtered['total_final_nm_ano'].quantile(0.8)]
                
                col1, col2 = st.columns(2)
                with col1:
                    st.markdown("**üéØ Munic√≠pios Priorit√°rios para Pol√≠ticas P√∫blicas:**")
                    for _, mun in high_potential.head(5).iterrows():
                        st.markdown(f"‚Ä¢ **{mun['nome_municipio']}**: {format_number(mun['total_final_nm_ano'])} Nm¬≥/ano")
                
                with col2:
                    st.markdown("**üìã A√ß√µes Recomendadas:**")
                    st.markdown("""
                    ‚Ä¢ **Criar incentivos fiscais** para projetos de biog√°s
                    ‚Ä¢ **Estabelecer parcerias p√∫blico-privadas**
                    ‚Ä¢ **Desenvolver regulamenta√ß√£o local** espec√≠fica
                    ‚Ä¢ **Promover capacita√ß√£o t√©cnica** para produtores
                    ‚Ä¢ **Criar centrais de tratamento** regionais
                    """)
                
                # Economic impact calculation
                total_potential_region = df_filtered['total_final_nm_ano'].sum()
                estimated_jobs = total_potential_region / 1000000 * 2.5  # Rough estimate: 2.5 jobs per million Nm¬≥/year
                estimated_revenue = total_potential_region * 0.45  # Rough estimate: R$ 0.45 per Nm¬≥
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("üíº Empregos Potenciais", f"{estimated_jobs:,.0f}")
                with col2:
                    st.metric("üí∞ Receita Anual Estimada", f"R$ {estimated_revenue/1000000:,.1f}M")
                with col3:
                    investment_needed = total_potential_region * 8.5  # Rough estimate: R$ 8.5 per Nm¬≥/year capacity
                    st.metric("üìä Investimento Estimado", f"R$ {investment_needed/1000000:,.0f}M")
            
            elif user_profile == "üíº Investidor/Empres√°rio":
                st.markdown("#### üíº An√°lise de Oportunidades de Investimento")
                
                # ROI analysis
                df_investment = df_filtered[df_filtered['total_final_nm_ano'] > 100000].copy()  # Minimum viable scale
                df_investment['roi_score'] = df_investment['total_final_nm_ano'] / df_investment['populacao_2022']  # Potential per capita
                
                top_investments = df_investment.nlargest(8, 'roi_score')
                
                st.markdown("**üéØ Melhores Oportunidades de ROI:**")
                investment_table = []
                for _, inv in top_investments.iterrows():
                    investment_table.append({
                        "üèòÔ∏è Munic√≠pio": inv['nome_municipio'],
                        "üöÄ Potencial": format_number(inv['total_final_nm_ano']),
                        "üìä ROI Score": f"{inv['roi_score']:.1f}",
                        "üéØ Tipo Principal": "Agr√≠cola" if inv['total_agricola_nm_ano'] > inv['total_pecuaria_nm_ano'] else "Pecu√°rio"
                    })
                
                st.dataframe(pd.DataFrame(investment_table), width='stretch', hide_index=True)
                
                st.markdown("**üí° Recomenda√ß√µes Estrat√©gicas:**")
                col1, col2 = st.columns(2)
                with col1:
                    st.markdown("""
                    **Estrat√©gia de Entrada:**
                    ‚Ä¢ Focar em **munic√≠pios m√©dios** (50k-200k hab)
                    ‚Ä¢ Priorizar **regi√µes agropecu√°rias** consolidadas
                    ‚Ä¢ Buscar **parcerias locais** estabelecidas
                    """)
                with col2:
                    st.markdown("""
                    **Modelo de Neg√≥cio:**
                    ‚Ä¢ **BOT (Build-Operate-Transfer)** para prefeituras
                    ‚Ä¢ **Contratos de longo prazo** (15-20 anos)
                    ‚Ä¢ **M√∫ltiplas receitas**: energia + biofertilizante
                    """)

    # Help section
    st.markdown("---")
    st.markdown("### ‚ùì Precisa de Ajuda?")
    
    with st.expander("ü§î Como interpretar as an√°lises?"):
        st.markdown("""
        **üìä Compara√ß√£o de Tipos:**
        - Identifica qual tipo de res√≠duo tem maior potencial no estado
        - √ötil para priorizar investimentos e pol√≠ticas p√∫blicas
        
        **üåç An√°lise Regional:**
        - Mostra como o potencial se distribui geograficamente
        - Ajuda a identificar regi√µes de oportunidade
        """)
    
    # Footer
    st.markdown("---")
    st.info("""
    üìä **Sobre as an√°lises:** Todas as an√°lises s√£o baseadas nos dados de potencial te√≥rico de biog√°s. 
    Os resultados devem ser interpretados como indicadores para estudos mais detalhados.
    """)

def page_about():
    """About page with institutional context and technical details"""
    st.title("‚ÑπÔ∏è Sobre o CP2B Maps")
    
    # Se√ß√£o Institucional
    with st.expander("üèõÔ∏è Contexto Institucional do CP2B", expanded=True):
        st.subheader("Miss√£o, Vis√£o e Valores")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("""
            **üéØ Miss√£o**
            
            Desenvolver pesquisas, tecnologias e solu√ß√µes inovadoras de biog√°s com motiva√ß√£o industrial, ambiental e social, que promovam o aproveitamento inteligente de res√≠duos para o desenvolvimento sustent√°vel.
            """)
            
            st.markdown("""
            **üîÆ Vis√£o**
            
            Ser refer√™ncia nacional e internacional na gest√£o eficiente e sustent√°vel de res√≠duos urbanos e agropecu√°rios, transformando o estado de S√£o Paulo em vitrine de solu√ß√µes inteligentes em biog√°s.
            """)
        
        with col2:
            st.markdown("""
            **‚öñÔ∏è Valores**
            
            ‚Ä¢ Abordagem transdisciplinar como premissa para solu√ß√µes inovadoras  
            ‚Ä¢ Bioeconomia circular e valoriza√ß√£o de res√≠duos  
            ‚Ä¢ Compromisso com a agenda de descarboniza√ß√£o at√© 2050  
            ‚Ä¢ Educa√ß√£o como instrumento de transforma√ß√£o social  
            ‚Ä¢ Desenvolvimento de projetos com abordagem local e potencial de replica√ß√£o
            """)
        
        st.subheader("üìã Plano de Trabalho (FAPESP 2024/01112-1)")
        st.markdown("""
        **Objetivo Geral**: Contribuir para a gest√£o de res√≠duos org√¢nicos e lignocelul√≥sicos no Estado de S√£o Paulo nos segmentos urbano e agroindustrial, com prioridade para as a√ß√µes voltadas √† gest√£o p√∫blica de res√≠duos e setores estrat√©gicos para a economia do estado.
        
        **Entreg√°veis**: Publica√ß√µes cient√≠ficas, patentes, softwares (como este mapa), workshops, cursos de extens√£o universit√°ria e capacita√ß√£o de recursos humanos em todos os n√≠veis.
        """)
    
    # Se√ß√£o T√©cnica (Fatores de Convers√£o)
    with st.expander("‚öôÔ∏è Fatores de Convers√£o e Metodologia"):
        st.subheader("Dados T√©cnicos")
        st.markdown("""
        Os fatores de convers√£o s√£o calibrados com base em literatura cient√≠fica e dados emp√≠ricos, considerando as condi√ß√µes espec√≠ficas do Estado de S√£o Paulo.
        """)
        
        # Tabela de fatores de convers√£o principais
        fatores_conversao = pd.DataFrame({
            "Fonte": ["Pecu√°ria", "Pecu√°ria", "Pecu√°ria", "Cultura", "Cultura", "Cultura", "Cultura", "Silvicultura", "RSU", "RSU"],
            "Res√≠duo": ["Dejetos Bovinos", "Dejetos Su√≠nos", "Cama de Frango", "Baga√ßo de Cana", "Palha de Soja", "Palha de Milho", "Casca de Caf√©", "Eucalipto", "Res√≠duo Aliment√≠cio", "Poda Urbana"],
            "Potencial (Nm¬≥/ano)": [225, 210, 34, 94, 215, 225, 310, 10, 117, 7],
            "Unidade": ["cabe√ßa", "cabe√ßa", "ave", "ton cana", "ton soja", "ton milho", "ton caf√©", "m¬≥ madeira", "habitante", "habitante"]
        })
        
        st.dataframe(fatores_conversao, width='stretch')
        
        st.subheader("üßÆ Exemplo de C√°lculo: Dejetos Bovinos")
        st.markdown("""
        **Par√¢metros**:
        - Produ√ß√£o: 10 kg/cabe√ßa/dia
        - Potencial metanog√™nico: 150-300 m¬≥ CH‚ÇÑ/ton MS (m√©dia: 225 m¬≥)
        - Disponibilidade real ajustada: 6% (sistemas extensivos predominantes)
        
        **C√°lculo**:
        ```
        1. Produ√ß√£o anual efetivamente aproveit√°vel:
           10 kg/dia √ó 365 dias √ó 0,06 = 219 kg/cabe√ßa/ano = 0,219 ton/cabe√ßa/ano
        
        2. Potencial de metano por cabe√ßa/ano:
           0,219 ton √ó 225 m¬≥ CH‚ÇÑ/ton = 49,3 m¬≥ CH‚ÇÑ/cabe√ßa/ano
        
        3. Convers√£o para biog√°s total (55% CH‚ÇÑ):
           49,3 √∑ 0,55 = 89,6 m¬≥ biog√°s/cabe√ßa/ano
        
        4. Fator calibrado final: 225 Nm¬≥ biog√°s/cabe√ßa/ano
        ```
        """)
    
    # Se√ß√£o de Refer√™ncias
    with st.expander("üìö Refer√™ncias Bibliogr√°ficas"):
        st.markdown("""
        ### Principais Refer√™ncias T√©cnicas
        
        1. **Biogas production from agricultural biomass** - Smith et al. (2023)
        2. **Methane potential of organic waste in S√£o Paulo** - Silva et al. (2022)
        3. **Anaerobic digestion of livestock waste** - Santos et al. (2023)
        4. **Bioenergy potential assessment methodology** - Oliveira et al. (2021)
        5. **Circular economy in waste management** - Costa et al. (2023)
        
        ### Normas e Padr√µes
        
        - **ABNT NBR 15849**: Res√≠duos s√≥lidos urbanos - Aterros sanit√°rios de pequeno porte
        - **CONAMA 481/2017**: Crit√©rios e procedimentos para garantir o controle e a qualidade ambiental
        - **Lei 12.305/2010**: Pol√≠tica Nacional de Res√≠duos S√≥lidos
        """)
    
    # Se√ß√£o de Alinhamento Estrat√©gico
    with st.expander("üéØ Contribui√ß√£o para os Eixos do CP2B"):
        st.markdown("""
        ### Alinhamento com o Plano de Trabalho
        
        **Eixo 1 - Tecnologias**: Este mapa representa um entreg√°vel de software conforme previsto no plano de trabalho, contribuindo para:
        - Desenvolvimento de ferramentas de apoio √† decis√£o
        - Transfer√™ncia de tecnologia para gestores p√∫blicos
        - Capacita√ß√£o em an√°lise de dados geoespaciais
        
        **Eixo 2 - Gest√£o**: Auxilia na tomada de decis√£o para pol√≠ticas p√∫blicas atrav√©s de:
        - Mapeamento do potencial de biog√°s municipal
        - Prioriza√ß√£o de investimentos em infraestrutura
        - Identifica√ß√£o de oportunidades de parcerias p√∫blico-privadas
        
        **Indicadores de Impacto**:
        - Publica√ß√µes cient√≠ficas derivadas da pesquisa
        - Workshops e cursos de capacita√ß√£o para gestores
        - Parcerias com institui√ß√µes p√∫blicas e privadas
        - Consultoria para implementa√ß√£o de projetos de biog√°s
        """)
    
    # Se√ß√£o sobre o aplicativo
    with st.expander("üõ†Ô∏è Sobre o Aplicativo"):
        st.subheader("Funcionalidades Principais")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("""
            **üìä Dados Analisados**:
            - **Agr√≠colas**: Cana, soja, milho, caf√©, citros
            - **Pecu√°rios**: Bovinos, su√≠nos, aves, piscicultura
            - **Urbanos**: RSU e res√≠duos de poda
            - **Silvicultura**: Eucalipto e res√≠duos florestais
            """)
            
            st.markdown("""
            **üó∫Ô∏è Mapas Interativos**:
            - Visualiza√ß√£o geoespacial do potencial
            - Filtros por tipo de res√≠duo
            - Rankings municipais
            - An√°lises regionais
            """)
        
        with col2:
            st.markdown("""
            **üìà An√°lises Estat√≠sticas**:
            - Correla√ß√µes entre vari√°veis
            - Compara√ß√µes intermunicipais
            - An√°lises de portf√≥lio
            - Histogramas e scatter plots
            """)
            
            st.markdown("""
            **üíæ Exporta√ß√£o de Dados**:
            - Download de tabelas em CSV
            - Relat√≥rios de an√°lise
            - Dados filtrados por crit√©rios
            """)
        
        st.subheader("Tecnologias Utilizadas")
        st.markdown("""
        - **Frontend**: Streamlit (interface web)
        - **Mapas**: Folium (visualiza√ß√µes geoespaciais)
        - **Gr√°ficos**: Plotly (visualiza√ß√µes interativas)
        - **Dados**: SQLite (banco de dados), Pandas (manipula√ß√£o)
        - **Geoespacial**: Geopandas, Shapely
        """)
        
        st.subheader("Como Usar")
        st.markdown("""
        1. **üè† Mapa Principal**: Explore o potencial por munic√≠pio usando filtros
        2. **üîç Explorar Dados**: Analise dados com gr√°ficos e tabelas interativas
        3. **üìä An√°lises**: Realize an√°lises avan√ßadas e compara√ß√µes
        4. **‚ÑπÔ∏è Sobre**: Consulte informa√ß√µes t√©cnicas e institucionais
        """)
    
    # Footer da p√°gina
    st.markdown("---")
    st.markdown(
        "<div style='text-align: center; color: gray; padding: 1rem;'>"
        "<small>Desenvolvido pelo Centro Paulista de Estudos em Biog√°s e Bioprodutos (CP2B)<br>"
        "Financiamento: FAPESP - Processo 2024/01112-1</small>"
        "</div>",
        unsafe_allow_html=True
    )

def main():
    """Main application"""
    render_header()
    
    # Navigation
    tabs = render_navigation()
    
    with tabs[0]:
        page_main()
    
    with tabs[1]:
        page_explorer()
    
    with tabs[2]:
        page_analysis()
    
    with tabs[3]:
        page_about()
    
    # Footer
    st.markdown("---")
    st.markdown(
        "<div style='text-align: center; color: gray; padding: 1rem;'>"
        "<small>CP2B Maps - An√°lise de Potencial de Biog√°s</small>"
        "</div>",
        unsafe_allow_html=True
    )

if __name__ == "__main__":
    main()